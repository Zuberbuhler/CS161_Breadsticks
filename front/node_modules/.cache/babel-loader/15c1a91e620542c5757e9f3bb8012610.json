{"ast":null,"code":"import { applyMiddleware, createStore } from 'redux';\nimport { e as error, h as UNDO, R as REDO, M as MAKE_MOVE } from './turn-order-0b7dce3d.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-07c7b307.js';\nimport { i as isSynchronous, c as createMatch } from './util-b1699aa1.js';\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\n\nconst filterMatchData = matchData => Object.values(matchData.players).map(player => {\n  const {\n    credentials,\n    ...filteredData\n  } = player;\n  return filteredData;\n});\n/**\r\n * Remove player credentials from action payload\r\n */\n\n\nconst stripCredentialsFromAction = action => {\n  const {\n    credentials,\n    ...payload\n  } = action.payload;\n  return { ...action,\n    payload\n  };\n};\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\n\n\nclass Master {\n  constructor(game, storageAPI, transportAPI, auth) {\n    this.game = ProcessGameConfig(game);\n    this.storageAPI = storageAPI;\n    this.transportAPI = transportAPI;\n\n    this.subscribeCallback = () => {};\n\n    this.auth = auth;\n  }\n\n  subscribe(fn) {\n    this.subscribeCallback = fn;\n  }\n  /**\r\n   * Called on each move / event made by the client.\r\n   * Computes the new value of the game state and returns it\r\n   * along with a deltalog.\r\n   */\n\n\n  async onUpdate(credAction, stateID, matchID, playerID) {\n    if (!credAction || !credAction.payload) {\n      return {\n        error: 'missing action or action payload'\n      };\n    }\n\n    let metadata;\n\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        metadata\n      } = this.storageAPI.fetch(matchID, {\n        metadata: true\n      }));\n    } else {\n      ({\n        metadata\n      } = await this.storageAPI.fetch(matchID, {\n        metadata: true\n      }));\n    }\n\n    if (this.auth) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials: credAction.payload.credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized action'\n        };\n      }\n    }\n\n    const action = stripCredentialsFromAction(credAction);\n    const key = matchID;\n    let state;\n\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        state\n      } = this.storageAPI.fetch(key, {\n        state: true\n      }));\n    } else {\n      ({\n        state\n      } = await this.storageAPI.fetch(key, {\n        state: true\n      }));\n    }\n\n    if (state === undefined) {\n      error(`game not found, matchID=[${key}]`);\n      return {\n        error: 'game not found'\n      };\n    }\n\n    if (state.ctx.gameover !== undefined) {\n      error(`game over - matchID=[${key}] - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    }\n\n    const reducer = CreateGameReducer({\n      game: this.game\n    });\n    const middleware = applyMiddleware(TransientHandlingMiddleware);\n    const store = createStore(reducer, state, middleware); // Only allow UNDO / REDO if there is exactly one player\n    // that can make moves right now and the person doing the\n    // action is that player.\n\n    if (action.type == UNDO || action.type == REDO) {\n      const hasActivePlayers = state.ctx.activePlayers !== null;\n      const isCurrentPlayer = state.ctx.currentPlayer === playerID;\n\n      if ( // If activePlayers is empty, non-current players can’t undo.\n      !hasActivePlayers && !isCurrentPlayer || // If player is not active or multiple players are active, can’t undo.\n      hasActivePlayers && (state.ctx.activePlayers[playerID] === undefined || Object.keys(state.ctx.activePlayers).length > 1)) {\n        error(`playerID=[${playerID}] cannot undo / redo right now`);\n        return;\n      }\n    } // Check whether the player is active.\n\n\n    if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\n      error(`player not active - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    } // Get move for further checks\n\n\n    const move = action.type == MAKE_MOVE ? this.game.flow.getMove(state.ctx, action.payload.type, playerID) : null; // Check whether the player is allowed to make the move.\n\n    if (action.type == MAKE_MOVE && !move) {\n      error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` + ` - action[${action.payload.type}]`);\n      return;\n    } // Check if action's stateID is different than store's stateID\n    // and if move does not have ignoreStaleStateID truthy.\n\n\n    if (state._stateID !== stateID && !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\n      error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` + ` - playerID=[${playerID}] - action[${action.payload.type}]`);\n      return;\n    }\n\n    const prevState = store.getState(); // Update server's version of the store.\n\n    store.dispatch(action);\n    state = store.getState();\n    this.subscribeCallback({\n      state,\n      action,\n      matchID\n    });\n\n    if (this.game.deltaState) {\n      this.transportAPI.sendAll({\n        type: 'patch',\n        args: [matchID, stateID, prevState, state]\n      });\n    } else {\n      this.transportAPI.sendAll({\n        type: 'update',\n        args: [matchID, state]\n      });\n    }\n\n    const {\n      deltalog,\n      ...stateWithoutDeltalog\n    } = state;\n    let newMetadata;\n\n    if (metadata && (metadata.gameover === undefined || metadata.gameover === null)) {\n      newMetadata = { ...metadata,\n        updatedAt: Date.now()\n      };\n\n      if (state.ctx.gameover !== undefined) {\n        newMetadata.gameover = state.ctx.gameover;\n      }\n    }\n\n    if (isSynchronous(this.storageAPI)) {\n      this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\n      if (newMetadata) this.storageAPI.setMetadata(key, newMetadata);\n    } else {\n      const writes = [this.storageAPI.setState(key, stateWithoutDeltalog, deltalog)];\n\n      if (newMetadata) {\n        writes.push(this.storageAPI.setMetadata(key, newMetadata));\n      }\n\n      await Promise.all(writes);\n    }\n  }\n  /**\r\n   * Called when the client connects / reconnects.\r\n   * Returns the latest game state and the entire log.\r\n   */\n\n\n  async onSync(matchID, playerID, credentials) {\n    let numPlayers = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;\n    const key = matchID;\n    const fetchOpts = {\n      state: true,\n      metadata: true,\n      log: true,\n      initialState: true\n    };\n    const fetchResult = isSynchronous(this.storageAPI) ? this.storageAPI.fetch(key, fetchOpts) : await this.storageAPI.fetch(key, fetchOpts);\n    let {\n      state,\n      initialState,\n      log,\n      metadata\n    } = fetchResult;\n\n    if (this.auth && playerID !== undefined && playerID !== null) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    } // If the game doesn't exist, then create one on demand.\n    // TODO: Move this out of the sync call.\n\n\n    if (state === undefined) {\n      const match = createMatch({\n        game: this.game,\n        unlisted: true,\n        numPlayers,\n        setupData: undefined\n      });\n\n      if ('setupDataError' in match) {\n        return {\n          error: 'game requires setupData'\n        };\n      }\n\n      initialState = state = match.initialState;\n      metadata = match.metadata;\n      this.subscribeCallback({\n        state,\n        matchID\n      });\n\n      if (isSynchronous(this.storageAPI)) {\n        this.storageAPI.createMatch(key, {\n          initialState,\n          metadata\n        });\n      } else {\n        await this.storageAPI.createMatch(key, {\n          initialState,\n          metadata\n        });\n      }\n    }\n\n    const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\n    const syncInfo = {\n      state,\n      log,\n      filteredMetadata,\n      initialState\n    };\n    this.transportAPI.send({\n      playerID,\n      type: 'sync',\n      args: [matchID, syncInfo]\n    });\n    return;\n  }\n  /**\r\n   * Called when a client connects or disconnects.\r\n   * Updates and sends out metadata to reflect the player’s connection status.\r\n   */\n\n\n  async onConnectionChange(matchID, playerID, credentials, connected) {\n    const key = matchID; // Ignore changes for clients without a playerID, e.g. spectators.\n\n    if (playerID === undefined || playerID === null) {\n      return;\n    }\n\n    let metadata;\n\n    if (isSynchronous(this.storageAPI)) {\n      ({\n        metadata\n      } = this.storageAPI.fetch(key, {\n        metadata: true\n      }));\n    } else {\n      ({\n        metadata\n      } = await this.storageAPI.fetch(key, {\n        metadata: true\n      }));\n    }\n\n    if (metadata === undefined) {\n      error(`metadata not found for matchID=[${key}]`);\n      return {\n        error: 'metadata not found'\n      };\n    }\n\n    if (metadata.players[playerID] === undefined) {\n      error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\n      return {\n        error: 'player not in the match'\n      };\n    }\n\n    if (this.auth) {\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID,\n        credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n\n    metadata.players[playerID].isConnected = connected;\n    const filteredMetadata = filterMatchData(metadata);\n    this.transportAPI.sendAll({\n      type: 'matchData',\n      args: [matchID, filteredMetadata]\n    });\n\n    if (isSynchronous(this.storageAPI)) {\n      this.storageAPI.setMetadata(key, metadata);\n    } else {\n      await this.storageAPI.setMetadata(key, metadata);\n    }\n  }\n\n  async onChatMessage(matchID, chatMessage, credentials) {\n    const key = matchID;\n\n    if (this.auth) {\n      const {\n        metadata\n      } = await this.storageAPI.fetch(key, {\n        metadata: true\n      });\n\n      if (!(chatMessage && typeof chatMessage.sender === 'string')) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n\n      const isAuthentic = await this.auth.authenticateCredentials({\n        playerID: chatMessage.sender,\n        credentials,\n        metadata\n      });\n\n      if (!isAuthentic) {\n        return {\n          error: 'unauthorized'\n        };\n      }\n    }\n\n    this.transportAPI.sendAll({\n      type: 'chat',\n      args: [matchID, chatMessage]\n    });\n  }\n\n}\n\nexport { Master as M };","map":{"version":3,"sources":["/Users/andywang/Desktop/CS161_Breadsticks/node_modules/boardgame.io/dist/esm/master-be1abdd0.js"],"names":["applyMiddleware","createStore","e","error","h","UNDO","R","REDO","M","MAKE_MOVE","P","ProcessGameConfig","C","CreateGameReducer","T","TransientHandlingMiddleware","I","IsLongFormMove","i","isSynchronous","c","createMatch","filterMatchData","matchData","Object","values","players","map","player","credentials","filteredData","stripCredentialsFromAction","action","payload","Master","constructor","game","storageAPI","transportAPI","auth","subscribeCallback","subscribe","fn","onUpdate","credAction","stateID","matchID","playerID","metadata","fetch","isAuthentic","authenticateCredentials","key","state","undefined","ctx","gameover","type","reducer","middleware","store","hasActivePlayers","activePlayers","isCurrentPlayer","currentPlayer","keys","length","flow","isPlayerActive","G","move","getMove","_stateID","ignoreStaleStateID","prevState","getState","dispatch","deltaState","sendAll","args","deltalog","stateWithoutDeltalog","newMetadata","updatedAt","Date","now","setState","setMetadata","writes","push","Promise","all","onSync","numPlayers","fetchOpts","log","initialState","fetchResult","match","unlisted","setupData","filteredMetadata","syncInfo","send","onConnectionChange","connected","isConnected","onChatMessage","chatMessage","sender"],"mappings":"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","sourcesContent":["import { applyMiddleware, createStore } from 'redux';\nimport { e as error, h as UNDO, R as REDO, M as MAKE_MOVE } from './turn-order-0b7dce3d.js';\nimport { P as ProcessGameConfig, C as CreateGameReducer, T as TransientHandlingMiddleware, I as IsLongFormMove } from './reducer-07c7b307.js';\nimport { i as isSynchronous, c as createMatch } from './util-b1699aa1.js';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Filter match data to get a player metadata object with credentials stripped.\r\n */\r\nconst filterMatchData = (matchData) => Object.values(matchData.players).map((player) => {\r\n    const { credentials, ...filteredData } = player;\r\n    return filteredData;\r\n});\r\n/**\r\n * Remove player credentials from action payload\r\n */\r\nconst stripCredentialsFromAction = (action) => {\r\n    const { credentials, ...payload } = action.payload;\r\n    return { ...action, payload };\r\n};\r\n/**\r\n * Master\r\n *\r\n * Class that runs the game and maintains the authoritative state.\r\n * It uses the transportAPI to communicate with clients and the\r\n * storageAPI to communicate with the database.\r\n */\r\nclass Master {\r\n    constructor(game, storageAPI, transportAPI, auth) {\r\n        this.game = ProcessGameConfig(game);\r\n        this.storageAPI = storageAPI;\r\n        this.transportAPI = transportAPI;\r\n        this.subscribeCallback = () => { };\r\n        this.auth = auth;\r\n    }\r\n    subscribe(fn) {\r\n        this.subscribeCallback = fn;\r\n    }\r\n    /**\r\n     * Called on each move / event made by the client.\r\n     * Computes the new value of the game state and returns it\r\n     * along with a deltalog.\r\n     */\r\n    async onUpdate(credAction, stateID, matchID, playerID) {\r\n        if (!credAction || !credAction.payload) {\r\n            return { error: 'missing action or action payload' };\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(matchID, { metadata: true }));\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials: credAction.payload.credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized action' };\r\n            }\r\n        }\r\n        const action = stripCredentialsFromAction(credAction);\r\n        const key = matchID;\r\n        let state;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ state } = this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        else {\r\n            ({ state } = await this.storageAPI.fetch(key, { state: true }));\r\n        }\r\n        if (state === undefined) {\r\n            error(`game not found, matchID=[${key}]`);\r\n            return { error: 'game not found' };\r\n        }\r\n        if (state.ctx.gameover !== undefined) {\r\n            error(`game over - matchID=[${key}] - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const reducer = CreateGameReducer({\r\n            game: this.game,\r\n        });\r\n        const middleware = applyMiddleware(TransientHandlingMiddleware);\r\n        const store = createStore(reducer, state, middleware);\r\n        // Only allow UNDO / REDO if there is exactly one player\r\n        // that can make moves right now and the person doing the\r\n        // action is that player.\r\n        if (action.type == UNDO || action.type == REDO) {\r\n            const hasActivePlayers = state.ctx.activePlayers !== null;\r\n            const isCurrentPlayer = state.ctx.currentPlayer === playerID;\r\n            if (\r\n            // If activePlayers is empty, non-current players can’t undo.\r\n            (!hasActivePlayers && !isCurrentPlayer) ||\r\n                // If player is not active or multiple players are active, can’t undo.\r\n                (hasActivePlayers &&\r\n                    (state.ctx.activePlayers[playerID] === undefined ||\r\n                        Object.keys(state.ctx.activePlayers).length > 1))) {\r\n                error(`playerID=[${playerID}] cannot undo / redo right now`);\r\n                return;\r\n            }\r\n        }\r\n        // Check whether the player is active.\r\n        if (!this.game.flow.isPlayerActive(state.G, state.ctx, playerID)) {\r\n            error(`player not active - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Get move for further checks\r\n        const move = action.type == MAKE_MOVE\r\n            ? this.game.flow.getMove(state.ctx, action.payload.type, playerID)\r\n            : null;\r\n        // Check whether the player is allowed to make the move.\r\n        if (action.type == MAKE_MOVE && !move) {\r\n            error(`move not processed - canPlayerMakeMove=false - playerID=[${playerID}]` +\r\n                ` - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        // Check if action's stateID is different than store's stateID\r\n        // and if move does not have ignoreStaleStateID truthy.\r\n        if (state._stateID !== stateID &&\r\n            !(move && IsLongFormMove(move) && move.ignoreStaleStateID)) {\r\n            error(`invalid stateID, was=[${stateID}], expected=[${state._stateID}]` +\r\n                ` - playerID=[${playerID}] - action[${action.payload.type}]`);\r\n            return;\r\n        }\r\n        const prevState = store.getState();\r\n        // Update server's version of the store.\r\n        store.dispatch(action);\r\n        state = store.getState();\r\n        this.subscribeCallback({\r\n            state,\r\n            action,\r\n            matchID,\r\n        });\r\n        if (this.game.deltaState) {\r\n            this.transportAPI.sendAll({\r\n                type: 'patch',\r\n                args: [matchID, stateID, prevState, state],\r\n            });\r\n        }\r\n        else {\r\n            this.transportAPI.sendAll({\r\n                type: 'update',\r\n                args: [matchID, state],\r\n            });\r\n        }\r\n        const { deltalog, ...stateWithoutDeltalog } = state;\r\n        let newMetadata;\r\n        if (metadata &&\r\n            (metadata.gameover === undefined || metadata.gameover === null)) {\r\n            newMetadata = {\r\n                ...metadata,\r\n                updatedAt: Date.now(),\r\n            };\r\n            if (state.ctx.gameover !== undefined) {\r\n                newMetadata.gameover = state.ctx.gameover;\r\n            }\r\n        }\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setState(key, stateWithoutDeltalog, deltalog);\r\n            if (newMetadata)\r\n                this.storageAPI.setMetadata(key, newMetadata);\r\n        }\r\n        else {\r\n            const writes = [\r\n                this.storageAPI.setState(key, stateWithoutDeltalog, deltalog),\r\n            ];\r\n            if (newMetadata) {\r\n                writes.push(this.storageAPI.setMetadata(key, newMetadata));\r\n            }\r\n            await Promise.all(writes);\r\n        }\r\n    }\r\n    /**\r\n     * Called when the client connects / reconnects.\r\n     * Returns the latest game state and the entire log.\r\n     */\r\n    async onSync(matchID, playerID, credentials, numPlayers = 2) {\r\n        const key = matchID;\r\n        const fetchOpts = {\r\n            state: true,\r\n            metadata: true,\r\n            log: true,\r\n            initialState: true,\r\n        };\r\n        const fetchResult = isSynchronous(this.storageAPI)\r\n            ? this.storageAPI.fetch(key, fetchOpts)\r\n            : await this.storageAPI.fetch(key, fetchOpts);\r\n        let { state, initialState, log, metadata } = fetchResult;\r\n        if (this.auth && playerID !== undefined && playerID !== null) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        // If the game doesn't exist, then create one on demand.\r\n        // TODO: Move this out of the sync call.\r\n        if (state === undefined) {\r\n            const match = createMatch({\r\n                game: this.game,\r\n                unlisted: true,\r\n                numPlayers,\r\n                setupData: undefined,\r\n            });\r\n            if ('setupDataError' in match) {\r\n                return { error: 'game requires setupData' };\r\n            }\r\n            initialState = state = match.initialState;\r\n            metadata = match.metadata;\r\n            this.subscribeCallback({ state, matchID });\r\n            if (isSynchronous(this.storageAPI)) {\r\n                this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n            else {\r\n                await this.storageAPI.createMatch(key, { initialState, metadata });\r\n            }\r\n        }\r\n        const filteredMetadata = metadata ? filterMatchData(metadata) : undefined;\r\n        const syncInfo = {\r\n            state,\r\n            log,\r\n            filteredMetadata,\r\n            initialState,\r\n        };\r\n        this.transportAPI.send({\r\n            playerID,\r\n            type: 'sync',\r\n            args: [matchID, syncInfo],\r\n        });\r\n        return;\r\n    }\r\n    /**\r\n     * Called when a client connects or disconnects.\r\n     * Updates and sends out metadata to reflect the player’s connection status.\r\n     */\r\n    async onConnectionChange(matchID, playerID, credentials, connected) {\r\n        const key = matchID;\r\n        // Ignore changes for clients without a playerID, e.g. spectators.\r\n        if (playerID === undefined || playerID === null) {\r\n            return;\r\n        }\r\n        let metadata;\r\n        if (isSynchronous(this.storageAPI)) {\r\n            ({ metadata } = this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        else {\r\n            ({ metadata } = await this.storageAPI.fetch(key, { metadata: true }));\r\n        }\r\n        if (metadata === undefined) {\r\n            error(`metadata not found for matchID=[${key}]`);\r\n            return { error: 'metadata not found' };\r\n        }\r\n        if (metadata.players[playerID] === undefined) {\r\n            error(`Player not in the match, matchID=[${key}] playerID=[${playerID}]`);\r\n            return { error: 'player not in the match' };\r\n        }\r\n        if (this.auth) {\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        metadata.players[playerID].isConnected = connected;\r\n        const filteredMetadata = filterMatchData(metadata);\r\n        this.transportAPI.sendAll({\r\n            type: 'matchData',\r\n            args: [matchID, filteredMetadata],\r\n        });\r\n        if (isSynchronous(this.storageAPI)) {\r\n            this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n        else {\r\n            await this.storageAPI.setMetadata(key, metadata);\r\n        }\r\n    }\r\n    async onChatMessage(matchID, chatMessage, credentials) {\r\n        const key = matchID;\r\n        if (this.auth) {\r\n            const { metadata } = await this.storageAPI.fetch(key, {\r\n                metadata: true,\r\n            });\r\n            if (!(chatMessage && typeof chatMessage.sender === 'string')) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n            const isAuthentic = await this.auth.authenticateCredentials({\r\n                playerID: chatMessage.sender,\r\n                credentials,\r\n                metadata,\r\n            });\r\n            if (!isAuthentic) {\r\n                return { error: 'unauthorized' };\r\n            }\r\n        }\r\n        this.transportAPI.sendAll({\r\n            type: 'chat',\r\n            args: [matchID, chatMessage],\r\n        });\r\n    }\r\n}\n\nexport { Master as M };\n"]},"metadata":{},"sourceType":"module"}