{"ast":null,"code":"import produce from 'immer';\nimport { R as RandomPlugin } from './plugin-random-087f861e.js';\nimport isPlainObject from 'lodash.isplainobject';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\nconst MAKE_MOVE = 'MAKE_MOVE';\nconst GAME_EVENT = 'GAME_EVENT';\nconst REDO = 'REDO';\nconst RESET = 'RESET';\nconst SYNC = 'SYNC';\nconst UNDO = 'UNDO';\nconst UPDATE = 'UPDATE';\nconst PATCH = 'PATCH';\nconst PLUGIN = 'PLUGIN';\nconst STRIP_TRANSIENTS = 'STRIP_TRANSIENTS';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Generate a move to be dispatched to the game move reducer.\r\n *\r\n * @param {string} type - The move type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\nconst makeMove = (type, args, playerID, credentials) => ({\n  type: MAKE_MOVE,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Generate a game event to be dispatched to the flow reducer.\r\n *\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst gameEvent = (type, args, playerID, credentials) => ({\n  type: GAME_EVENT,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Generate an automatic game event that is a side-effect of a move.\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst automaticGameEvent = (type, args, playerID, credentials) => ({\n  type: GAME_EVENT,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  },\n  automatic: true\n});\n\nconst sync = info => ({\n  type: SYNC,\n  state: info.state,\n  log: info.log,\n  initialState: info.initialState,\n  clientOnly: true\n});\n/**\r\n * Used to update the Redux store's state with patch in response to\r\n * an action coming from another player.\r\n * @param prevStateID previous stateID\r\n * @param stateID stateID after this patch\r\n * @param {Operation[]} patch - The patch to apply.\r\n * @param {LogEntry[]} deltalog - A log delta.\r\n */\n\n\nconst patch = (prevStateID, stateID, patch, deltalog) => ({\n  type: PATCH,\n  prevStateID,\n  stateID,\n  patch,\n  deltalog,\n  clientOnly: true\n});\n/**\r\n * Used to update the Redux store's state in response to\r\n * an action coming from another player.\r\n * @param {object} state - The state to restore.\r\n * @param {Array} deltalog - A log delta.\r\n */\n\n\nconst update = (state, deltalog) => ({\n  type: UPDATE,\n  state,\n  deltalog,\n  clientOnly: true\n});\n/**\r\n * Used to reset the game state.\r\n * @param {object} state - The initial state.\r\n */\n\n\nconst reset = state => ({\n  type: RESET,\n  state,\n  clientOnly: true\n});\n/**\r\n * Used to undo the last move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst undo = (playerID, credentials) => ({\n  type: UNDO,\n  payload: {\n    type: null,\n    args: null,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Used to redo the last undone move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\n\n\nconst redo = (playerID, credentials) => ({\n  type: REDO,\n  payload: {\n    type: null,\n    args: null,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Allows plugins to define their own actions and intercept them.\r\n */\n\n\nconst plugin = (type, args, playerID, credentials) => ({\n  type: PLUGIN,\n  payload: {\n    type,\n    args,\n    playerID,\n    credentials\n  }\n});\n/**\r\n * Private action used to strip transient metadata (e.g. errors) from the game\r\n * state.\r\n */\n\n\nconst stripTransients = () => ({\n  type: STRIP_TRANSIENTS\n});\n\nvar ActionCreators = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  makeMove: makeMove,\n  gameEvent: gameEvent,\n  automaticGameEvent: automaticGameEvent,\n  sync: sync,\n  patch: patch,\n  update: update,\n  reset: reset,\n  undo: undo,\n  redo: redo,\n  plugin: plugin,\n  stripTransients: stripTransients\n});\n/**\r\n * Moves can return this when they want to indicate\r\n * that the combination of arguments is illegal and\r\n * the move ought to be discarded.\r\n */\n\nconst INVALID_MOVE = 'INVALID_MOVE';\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Plugin that allows using Immer to make immutable changes\r\n * to G by just mutating it.\r\n */\n\nconst ImmerPlugin = {\n  name: 'plugin-immer',\n  fnWrap: move => function (G, ctx) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    let isInvalid = false;\n    const newG = produce(G, G => {\n      const result = move(G, ctx, ...args);\n\n      if (result === INVALID_MOVE) {\n        isInvalid = true;\n        return;\n      }\n\n      return result;\n    });\n    if (isInvalid) return INVALID_MOVE;\n    return newG;\n  }\n};\nvar GameMethod;\n\n(function (GameMethod) {\n  GameMethod[\"MOVE\"] = \"MOVE\";\n  GameMethod[\"GAME_ON_END\"] = \"GAME_ON_END\";\n  GameMethod[\"PHASE_ON_BEGIN\"] = \"PHASE_ON_BEGIN\";\n  GameMethod[\"PHASE_ON_END\"] = \"PHASE_ON_END\";\n  GameMethod[\"TURN_ON_BEGIN\"] = \"TURN_ON_BEGIN\";\n  GameMethod[\"TURN_ON_MOVE\"] = \"TURN_ON_MOVE\";\n  GameMethod[\"TURN_ON_END\"] = \"TURN_ON_END\";\n})(GameMethod || (GameMethod = {}));\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nvar Errors;\n\n(function (Errors) {\n  Errors[\"CalledOutsideHook\"] = \"Events must be called from moves or the `onBegin`, `onEnd`, and `onMove` hooks.\\nThis error probably means you called an event from other game code, like an `endIf` trigger or one of the `turn.order` methods.\";\n  Errors[\"EndTurnInOnEnd\"] = \"`endTurn` is disallowed in `onEnd` hooks \\u2014 the turn is already ending.\";\n  Errors[\"MaxTurnEndings\"] = \"Maximum number of turn endings exceeded for this update.\\nThis likely means game code is triggering an infinite loop.\";\n  Errors[\"PhaseEventInOnEnd\"] = \"`setPhase` & `endPhase` are disallowed in a phase\\u2019s `onEnd` hook \\u2014 the phase is already ending.\\nIf you\\u2019re trying to dynamically choose the next phase when a phase ends, use the phase\\u2019s `next` trigger.\";\n  Errors[\"StageEventInOnEnd\"] = \"`setStage`, `endStage` & `setActivePlayers` are disallowed in `onEnd` hooks.\";\n  Errors[\"StageEventInPhaseBegin\"] = \"`setStage`, `endStage` & `setActivePlayers` are disallowed in a phase\\u2019s `onBegin` hook.\\nUse `setActivePlayers` in a `turn.onBegin` hook or declare stages with `turn.activePlayers` instead.\";\n  Errors[\"StageEventInTurnBegin\"] = \"`setStage` & `endStage` are disallowed in `turn.onBegin`.\\nUse `setActivePlayers` or declare stages with `turn.activePlayers` instead.\";\n})(Errors || (Errors = {}));\n/**\r\n * Events\r\n */\n\n\nclass Events {\n  constructor(flow, ctx, playerID) {\n    this.flow = flow;\n    this.playerID = playerID;\n    this.dispatch = [];\n    this.initialTurn = ctx.turn;\n    this.updateTurnContext(ctx, undefined); // This is an arbitrarily large upper threshold, which could be made\n    // configurable via a game option if the need arises.\n\n    this.maxEndedTurnsPerAction = ctx.numPlayers * 100;\n  }\n\n  api() {\n    var _this = this;\n\n    const events = {\n      _private: this\n    };\n\n    for (const type of this.flow.eventNames) {\n      events[type] = function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        _this.dispatch.push({\n          type,\n          args,\n          phase: _this.currentPhase,\n          turn: _this.currentTurn,\n          calledFrom: _this.currentMethod,\n          // Used to capture a stack trace in case it is needed later.\n          error: new Error('Events Plugin Error')\n        });\n      };\n    }\n\n    return events;\n  }\n\n  isUsed() {\n    return this.dispatch.length > 0;\n  }\n\n  updateTurnContext(ctx, methodType) {\n    this.currentPhase = ctx.phase;\n    this.currentTurn = ctx.turn;\n    this.currentMethod = methodType;\n  }\n\n  unsetCurrentMethod() {\n    this.currentMethod = undefined;\n  }\n  /**\r\n   * Updates ctx with the triggered events.\r\n   * @param {object} state - The state object { G, ctx }.\r\n   */\n\n\n  update(state) {\n    const initialState = state;\n\n    const stateWithError = (_ref, message) => {\n      let {\n        stack\n      } = _ref;\n      return { ...initialState,\n        plugins: { ...initialState.plugins,\n          events: { ...initialState.plugins.events,\n            data: {\n              error: message + '\\n' + stack\n            }\n          }\n        }\n      };\n    };\n\n    EventQueue: for (let i = 0; i < this.dispatch.length; i++) {\n      const event = this.dispatch[i];\n      const turnHasEnded = event.turn !== state.ctx.turn; // This protects against potential infinite loops if specific events are called on hooks.\n      // The moment we exceed the defined threshold, we just bail out of all phases.\n\n      const endedTurns = this.currentTurn - this.initialTurn;\n\n      if (endedTurns >= this.maxEndedTurnsPerAction) {\n        return stateWithError(event.error, Errors.MaxTurnEndings);\n      }\n\n      if (event.calledFrom === undefined) {\n        return stateWithError(event.error, Errors.CalledOutsideHook);\n      } // Stop processing events once the game has finished.\n\n\n      if (state.ctx.gameover) break EventQueue;\n\n      switch (event.type) {\n        case 'endStage':\n        case 'setStage':\n        case 'setActivePlayers':\n          {\n            switch (event.calledFrom) {\n              // Disallow all stage events in onEnd and phase.onBegin hooks.\n              case GameMethod.TURN_ON_END:\n              case GameMethod.PHASE_ON_END:\n                return stateWithError(event.error, Errors.StageEventInOnEnd);\n\n              case GameMethod.PHASE_ON_BEGIN:\n                return stateWithError(event.error, Errors.StageEventInPhaseBegin);\n              // Disallow setStage & endStage in turn.onBegin hooks.\n\n              case GameMethod.TURN_ON_BEGIN:\n                if (event.type === 'setActivePlayers') break;\n                return stateWithError(event.error, Errors.StageEventInTurnBegin);\n            } // If the turn already ended, don't try to process stage events.\n\n\n            if (turnHasEnded) continue EventQueue;\n            break;\n          }\n\n        case 'endTurn':\n          {\n            if (event.calledFrom === GameMethod.TURN_ON_END || event.calledFrom === GameMethod.PHASE_ON_END) {\n              return stateWithError(event.error, Errors.EndTurnInOnEnd);\n            } // If the turn already ended some other way,\n            // don't try to end the turn again.\n\n\n            if (turnHasEnded) continue EventQueue;\n            break;\n          }\n\n        case 'endPhase':\n        case 'setPhase':\n          {\n            if (event.calledFrom === GameMethod.PHASE_ON_END) {\n              return stateWithError(event.error, Errors.PhaseEventInOnEnd);\n            } // If the phase already ended some other way,\n            // don't try to end the phase again.\n\n\n            if (event.phase !== state.ctx.phase) continue EventQueue;\n            break;\n          }\n      }\n\n      const action = automaticGameEvent(event.type, event.args, this.playerID);\n      state = this.flow.processEvent(state, action);\n    }\n\n    return state;\n  }\n\n}\n/*\r\n * Copyright 2020 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nconst EventsPlugin = {\n  name: 'events',\n  noClient: _ref2 => {\n    let {\n      api\n    } = _ref2;\n    return api._private.isUsed();\n  },\n  isInvalid: _ref3 => {\n    let {\n      data\n    } = _ref3;\n    return data.error || false;\n  },\n  // Update the events plugin’s internal turn context each time a move\n  // or hook is called. This allows events called after turn or phase\n  // endings to dispatch the current turn and phase correctly.\n  fnWrap: (method, methodType) => function (G, ctx) {\n    const api = ctx.events;\n    if (api) api._private.updateTurnContext(ctx, methodType);\n\n    for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    G = method(G, ctx, ...args);\n    if (api) api._private.unsetCurrentMethod();\n    return G;\n  },\n  dangerouslyFlushRawState: _ref4 => {\n    let {\n      state,\n      api\n    } = _ref4;\n    return api._private.update(state);\n  },\n  api: _ref5 => {\n    let {\n      game,\n      ctx,\n      playerID\n    } = _ref5;\n    return new Events(game.flow, ctx, playerID).api();\n  }\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Plugin that makes it possible to add metadata to log entries.\r\n * During a move, you can set metadata using ctx.log.setMetadata and it will be\r\n * available on the log entry for that move.\r\n */\n\nconst LogPlugin = {\n  name: 'log',\n  flush: () => ({}),\n  api: _ref6 => {\n    let {\n      data\n    } = _ref6;\n    return {\n      setMetadata: metadata => {\n        data.metadata = metadata;\n      }\n    };\n  },\n  setup: () => ({})\n};\n/**\r\n * Check if a value can be serialized (e.g. using `JSON.stringify`).\r\n * Adapted from: https://stackoverflow.com/a/30712764/3829557\r\n */\n\nfunction isSerializable(value) {\n  // Primitives are OK.\n  if (value === undefined || value === null || typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') {\n    return true;\n  } // A non-primitive value that is neither a POJO or an array cannot be serialized.\n\n\n  if (!isPlainObject(value) && !Array.isArray(value)) {\n    return false;\n  } // Recurse entries if the value is an object or array.\n\n\n  for (const key in value) {\n    if (!isSerializable(value[key])) return false;\n  }\n\n  return true;\n}\n/**\r\n * Plugin that checks whether state is serializable, in order to avoid\r\n * network serialization bugs.\r\n */\n\n\nconst SerializablePlugin = {\n  name: 'plugin-serializable',\n  fnWrap: move => function (G, ctx) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n      args[_key4 - 2] = arguments[_key4];\n    }\n\n    const result = move(G, ctx, ...args); // Check state in non-production environments.\n\n    if (process.env.NODE_ENV !== 'production' && !isSerializable(result)) {\n      throw new Error('Move state is not JSON-serialiazable.\\n' + 'See https://boardgame.io/documentation/#/?id=state for more information.');\n    }\n\n    return result;\n  }\n};\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\nconst production = process.env.NODE_ENV === 'production';\nconst logfn = production ? () => {} : function () {\n  return console.log(...arguments);\n};\n\nconst errorfn = function () {\n  return console.error(...arguments);\n};\n\nfunction info(msg) {\n  logfn(`INFO: ${msg}`);\n}\n\nfunction error(error) {\n  errorfn('ERROR:', error);\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * List of plugins that are always added.\r\n */\n\n\nconst CORE_PLUGINS = [ImmerPlugin, RandomPlugin, LogPlugin, SerializablePlugin];\nconst DEFAULT_PLUGINS = [...CORE_PLUGINS, EventsPlugin];\n/**\r\n * Allow plugins to intercept actions and process them.\r\n */\n\nconst ProcessAction = (state, action, opts) => {\n  // TODO(#723): Extend error handling to plugins.\n  opts.game.plugins.filter(plugin => plugin.action !== undefined).filter(plugin => plugin.name === action.payload.type).forEach(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name] || {\n      data: {}\n    };\n    const data = plugin.action(pluginState.data, action.payload);\n    state = { ...state,\n      plugins: { ...state.plugins,\n        [name]: { ...pluginState,\n          data\n        }\n      }\n    };\n  });\n  return state;\n};\n/**\r\n * The API's created by various plugins are stored in the plugins\r\n * section of the state object:\r\n *\r\n * {\r\n *   G: {},\r\n *   ctx: {},\r\n *   plugins: {\r\n *     plugin-a: {\r\n *       data: {},  // this is generated by the plugin at Setup / Flush.\r\n *       api: {},   // this is ephemeral and generated by Enhance.\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * This function takes these API's and stuffs them back into\r\n * ctx for consumption inside a move function or hook.\r\n */\n\n\nconst EnhanceCtx = state => {\n  const ctx = { ...state.ctx\n  };\n  const plugins = state.plugins || {};\n  Object.entries(plugins).forEach(_ref7 => {\n    let [name, {\n      api\n    }] = _ref7;\n    ctx[name] = api;\n  });\n  return ctx;\n};\n/**\r\n * Applies the provided plugins to the given move / flow function.\r\n *\r\n * @param methodToWrap - The move function or hook to apply the plugins to.\r\n * @param methodType - The type of the move or hook being wrapped.\r\n * @param plugins - The list of plugins.\r\n */\n\n\nconst FnWrap = (methodToWrap, methodType, plugins) => {\n  return [...CORE_PLUGINS, ...plugins, EventsPlugin].filter(plugin => plugin.fnWrap !== undefined).reduce((method, _ref8) => {\n    let {\n      fnWrap\n    } = _ref8;\n    return fnWrap(method, methodType);\n  }, methodToWrap);\n};\n/**\r\n * Allows the plugin to generate its initial state.\r\n */\n\n\nconst Setup = (state, opts) => {\n  [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.setup !== undefined).forEach(plugin => {\n    const name = plugin.name;\n    const data = plugin.setup({\n      G: state.G,\n      ctx: state.ctx,\n      game: opts.game\n    });\n    state = { ...state,\n      plugins: { ...state.plugins,\n        [name]: {\n          data\n        }\n      }\n    };\n  });\n  return state;\n};\n/**\r\n * Invokes the plugin before a move or event.\r\n * The API that the plugin generates is stored inside\r\n * the `plugins` section of the state (which is subsequently\r\n * merged into ctx).\r\n */\n\n\nconst Enhance = (state, opts) => {\n  [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.api !== undefined).forEach(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name] || {\n      data: {}\n    };\n    const api = plugin.api({\n      G: state.G,\n      ctx: state.ctx,\n      data: pluginState.data,\n      game: opts.game,\n      playerID: opts.playerID\n    });\n    state = { ...state,\n      plugins: { ...state.plugins,\n        [name]: { ...pluginState,\n          api\n        }\n      }\n    };\n  });\n  return state;\n};\n/**\r\n * Allows plugins to update their state after a move / event.\r\n */\n\n\nconst Flush = (state, opts) => {\n  // We flush the events plugin first, then custom plugins and the core plugins.\n  // This means custom plugins cannot use the events API but will be available in event hooks.\n  // Note that plugins are flushed in reverse, to allow custom plugins calling each other.\n  [...CORE_PLUGINS, ...opts.game.plugins, EventsPlugin].reverse().forEach(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name] || {\n      data: {}\n    };\n\n    if (plugin.flush) {\n      const newData = plugin.flush({\n        G: state.G,\n        ctx: state.ctx,\n        game: opts.game,\n        api: pluginState.api,\n        data: pluginState.data\n      });\n      state = { ...state,\n        plugins: { ...state.plugins,\n          [plugin.name]: {\n            data: newData\n          }\n        }\n      };\n    } else if (plugin.dangerouslyFlushRawState) {\n      state = plugin.dangerouslyFlushRawState({\n        state,\n        game: opts.game,\n        api: pluginState.api,\n        data: pluginState.data\n      }); // Remove everything other than data.\n\n      const data = state.plugins[name].data;\n      state = { ...state,\n        plugins: { ...state.plugins,\n          [plugin.name]: {\n            data\n          }\n        }\n      };\n    }\n  });\n  return state;\n};\n/**\r\n * Allows plugins to indicate if they should not be materialized on the client.\r\n * This will cause the client to discard the state update and wait for the\r\n * master instead.\r\n */\n\n\nconst NoClient = (state, opts) => {\n  return [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.noClient !== undefined).map(plugin => {\n    const name = plugin.name;\n    const pluginState = state.plugins[name];\n\n    if (pluginState) {\n      return plugin.noClient({\n        G: state.G,\n        ctx: state.ctx,\n        game: opts.game,\n        api: pluginState.api,\n        data: pluginState.data\n      });\n    }\n\n    return false;\n  }).includes(true);\n};\n/**\r\n * Allows plugins to indicate if the entire action should be thrown out\r\n * as invalid. This will cancel the entire state update.\r\n */\n\n\nconst IsInvalid = (state, opts) => {\n  const firstInvalidReturn = [...DEFAULT_PLUGINS, ...opts.game.plugins].filter(plugin => plugin.isInvalid !== undefined).map(plugin => {\n    const {\n      name\n    } = plugin;\n    const pluginState = state.plugins[name];\n    const message = plugin.isInvalid({\n      G: state.G,\n      ctx: state.ctx,\n      game: opts.game,\n      data: pluginState && pluginState.data\n    });\n    return message ? {\n      plugin: name,\n      message\n    } : false;\n  }).find(value => value);\n  return firstInvalidReturn || false;\n};\n/**\r\n * Update plugin state after move/event & check if plugins consider the update to be valid.\r\n * @returns Tuple of `[updatedState]` or `[originalState, invalidError]`.\r\n */\n\n\nconst FlushAndValidate = (state, opts) => {\n  const updatedState = Flush(state, opts);\n  const isInvalid = IsInvalid(updatedState, opts);\n  if (!isInvalid) return [updatedState];\n  const {\n    plugin,\n    message\n  } = isInvalid;\n  error(`${plugin} plugin declared action invalid:\\n${message}`);\n  return [state, isInvalid];\n};\n/**\r\n * Allows plugins to customize their data for specific players.\r\n * For example, a plugin may want to share no data with the client, or\r\n * want to keep some player data secret from opponents.\r\n */\n\n\nconst PlayerView = (_ref9, _ref10) => {\n  let {\n    G,\n    ctx,\n    plugins = {}\n  } = _ref9;\n  let {\n    game,\n    playerID\n  } = _ref10;\n  [...DEFAULT_PLUGINS, ...game.plugins].forEach(_ref11 => {\n    let {\n      name,\n      playerView\n    } = _ref11;\n    if (!playerView) return;\n    const {\n      data\n    } = plugins[name] || {\n      data: {}\n    };\n    const newData = playerView({\n      G,\n      ctx,\n      game,\n      data,\n      playerID\n    });\n    plugins = { ...plugins,\n      [name]: {\n        data: newData\n      }\n    };\n  });\n  return plugins;\n};\n/**\r\n * Adjust the given options to use the new minMoves/maxMoves if a legacy moveLimit was given\r\n * @param options The options object to apply backwards compatibility to\r\n * @param enforceMinMoves Use moveLimit to set both minMoves and maxMoves\r\n */\n\n\nfunction supportDeprecatedMoveLimit(options) {\n  let enforceMinMoves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (options.moveLimit) {\n    if (enforceMinMoves) {\n      options.minMoves = options.moveLimit;\n    }\n\n    options.maxMoves = options.moveLimit;\n    delete options.moveLimit;\n  }\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nfunction SetActivePlayers(ctx, arg) {\n  let activePlayers = {};\n  let _prevActivePlayers = [];\n  let _nextActivePlayers = null;\n  let _activePlayersMinMoves = {};\n  let _activePlayersMaxMoves = {};\n\n  if (Array.isArray(arg)) {\n    // support a simple array of player IDs as active players\n    const value = {};\n    arg.forEach(v => value[v] = Stage.NULL);\n    activePlayers = value;\n  } else {\n    // process active players argument object\n    // stages previously did not enforce minMoves, this behaviour is kept intentionally\n    supportDeprecatedMoveLimit(arg);\n\n    if (arg.next) {\n      _nextActivePlayers = arg.next;\n    }\n\n    if (arg.revert) {\n      _prevActivePlayers = [...ctx._prevActivePlayers, {\n        activePlayers: ctx.activePlayers,\n        _activePlayersMinMoves: ctx._activePlayersMinMoves,\n        _activePlayersMaxMoves: ctx._activePlayersMaxMoves,\n        _activePlayersNumMoves: ctx._activePlayersNumMoves\n      }];\n    }\n\n    if (arg.currentPlayer !== undefined) {\n      ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, ctx.currentPlayer, arg.currentPlayer);\n    }\n\n    if (arg.others !== undefined) {\n      for (let i = 0; i < ctx.playOrder.length; i++) {\n        const id = ctx.playOrder[i];\n\n        if (id !== ctx.currentPlayer) {\n          ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.others);\n        }\n      }\n    }\n\n    if (arg.all !== undefined) {\n      for (let i = 0; i < ctx.playOrder.length; i++) {\n        const id = ctx.playOrder[i];\n        ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.all);\n      }\n    }\n\n    if (arg.value) {\n      for (const id in arg.value) {\n        ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.value[id]);\n      }\n    }\n\n    if (arg.minMoves) {\n      for (const id in activePlayers) {\n        if (_activePlayersMinMoves[id] === undefined) {\n          _activePlayersMinMoves[id] = arg.minMoves;\n        }\n      }\n    }\n\n    if (arg.maxMoves) {\n      for (const id in activePlayers) {\n        if (_activePlayersMaxMoves[id] === undefined) {\n          _activePlayersMaxMoves[id] = arg.maxMoves;\n        }\n      }\n    }\n  }\n\n  if (Object.keys(activePlayers).length === 0) {\n    activePlayers = null;\n  }\n\n  if (Object.keys(_activePlayersMinMoves).length === 0) {\n    _activePlayersMinMoves = null;\n  }\n\n  if (Object.keys(_activePlayersMaxMoves).length === 0) {\n    _activePlayersMaxMoves = null;\n  }\n\n  const _activePlayersNumMoves = {};\n\n  for (const id in activePlayers) {\n    _activePlayersNumMoves[id] = 0;\n  }\n\n  return { ...ctx,\n    activePlayers,\n    _activePlayersMinMoves,\n    _activePlayersMaxMoves,\n    _activePlayersNumMoves,\n    _prevActivePlayers,\n    _nextActivePlayers\n  };\n}\n/**\r\n * Update activePlayers, setting it to previous, next or null values\r\n * when it becomes empty.\r\n * @param ctx\r\n */\n\n\nfunction UpdateActivePlayersOnceEmpty(ctx) {\n  let {\n    activePlayers,\n    _activePlayersMinMoves,\n    _activePlayersMaxMoves,\n    _activePlayersNumMoves,\n    _prevActivePlayers,\n    _nextActivePlayers\n  } = ctx;\n\n  if (activePlayers && Object.keys(activePlayers).length === 0) {\n    if (_nextActivePlayers) {\n      ctx = SetActivePlayers(ctx, _nextActivePlayers);\n      ({\n        activePlayers,\n        _activePlayersMinMoves,\n        _activePlayersMaxMoves,\n        _activePlayersNumMoves,\n        _prevActivePlayers\n      } = ctx);\n    } else if (_prevActivePlayers.length > 0) {\n      const lastIndex = _prevActivePlayers.length - 1;\n      ({\n        activePlayers,\n        _activePlayersMinMoves,\n        _activePlayersMaxMoves,\n        _activePlayersNumMoves\n      } = _prevActivePlayers[lastIndex]);\n      _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);\n    } else {\n      activePlayers = null;\n      _activePlayersMinMoves = null;\n      _activePlayersMaxMoves = null;\n    }\n  }\n\n  return { ...ctx,\n    activePlayers,\n    _activePlayersMinMoves,\n    _activePlayersMaxMoves,\n    _activePlayersNumMoves,\n    _prevActivePlayers\n  };\n}\n/**\r\n * Apply an active player argument to the given player ID\r\n * @param {Object} activePlayers\r\n * @param {Object} _activePlayersMinMoves\r\n * @param {Object} _activePlayersMaxMoves\r\n * @param {String} playerID The player to apply the parameter to\r\n * @param {(String|Object)} arg An active player argument\r\n */\n\n\nfunction ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, playerID, arg) {\n  if (typeof arg !== 'object' || arg === Stage.NULL) {\n    arg = {\n      stage: arg\n    };\n  }\n\n  if (arg.stage !== undefined) {\n    // stages previously did not enforce minMoves, this behaviour is kept intentionally\n    supportDeprecatedMoveLimit(arg);\n    activePlayers[playerID] = arg.stage;\n    if (arg.minMoves) _activePlayersMinMoves[playerID] = arg.minMoves;\n    if (arg.maxMoves) _activePlayersMaxMoves[playerID] = arg.maxMoves;\n  }\n}\n/**\r\n * Converts a playOrderPos index into its value in playOrder.\r\n * @param {Array} playOrder - An array of player ID's.\r\n * @param {number} playOrderPos - An index into the above.\r\n */\n\n\nfunction getCurrentPlayer(playOrder, playOrderPos) {\n  // convert to string in case playOrder is set to number[]\n  return playOrder[playOrderPos] + '';\n}\n/**\r\n * Called at the start of a turn to initialize turn order state.\r\n *\r\n * TODO: This is called inside StartTurn, which is called from\r\n * both UpdateTurn and StartPhase (so it's called at the beginning\r\n * of a new phase as well as between turns). We should probably\r\n * split it into two.\r\n */\n\n\nfunction InitTurnOrderState(state, turn) {\n  let {\n    G,\n    ctx\n  } = state;\n  const {\n    numPlayers\n  } = ctx;\n  const ctxWithAPI = EnhanceCtx(state);\n  const order = turn.order;\n  let playOrder = [...Array.from({\n    length: numPlayers\n  })].map((_, i) => i + '');\n\n  if (order.playOrder !== undefined) {\n    playOrder = order.playOrder(G, ctxWithAPI);\n  }\n\n  const playOrderPos = order.first(G, ctxWithAPI);\n  const posType = typeof playOrderPos;\n\n  if (posType !== 'number') {\n    error(`invalid value returned by turn.order.first — expected number got ${posType} “${playOrderPos}”.`);\n  }\n\n  const currentPlayer = getCurrentPlayer(playOrder, playOrderPos);\n  ctx = { ...ctx,\n    currentPlayer,\n    playOrderPos,\n    playOrder\n  };\n  ctx = SetActivePlayers(ctx, turn.activePlayers || {});\n  return ctx;\n}\n/**\r\n * Called at the end of each turn to update the turn order state.\r\n * @param {object} G - The game object G.\r\n * @param {object} ctx - The game object ctx.\r\n * @param {object} turn - A turn object for this phase.\r\n * @param {string} endTurnArg - An optional argument to endTurn that\r\n                                may specify the next player.\r\n */\n\n\nfunction UpdateTurnOrderState(state, currentPlayer, turn, endTurnArg) {\n  const order = turn.order;\n  let {\n    G,\n    ctx\n  } = state;\n  let playOrderPos = ctx.playOrderPos;\n  let endPhase = false;\n\n  if (endTurnArg && endTurnArg !== true) {\n    if (typeof endTurnArg !== 'object') {\n      error(`invalid argument to endTurn: ${endTurnArg}`);\n    }\n\n    Object.keys(endTurnArg).forEach(arg => {\n      switch (arg) {\n        case 'remove':\n          currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\n          break;\n\n        case 'next':\n          playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);\n          currentPlayer = endTurnArg.next;\n          break;\n\n        default:\n          error(`invalid argument to endTurn: ${arg}`);\n      }\n    });\n  } else {\n    const ctxWithAPI = EnhanceCtx(state);\n    const t = order.next(G, ctxWithAPI);\n    const type = typeof t;\n\n    if (t !== undefined && type !== 'number') {\n      error(`invalid value returned by turn.order.next — expected number or undefined got ${type} “${t}”.`);\n    }\n\n    if (t === undefined) {\n      endPhase = true;\n    } else {\n      playOrderPos = t;\n      currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\n    }\n  }\n\n  ctx = { ...ctx,\n    playOrderPos,\n    currentPlayer\n  };\n  return {\n    endPhase,\n    ctx\n  };\n}\n/**\r\n * Set of different turn orders possible in a phase.\r\n * These are meant to be passed to the `turn` setting\r\n * in the flow objects.\r\n *\r\n * Each object defines the first player when the phase / game\r\n * begins, and also a function `next` to determine who the\r\n * next player is when the turn ends.\r\n *\r\n * The phase ends if next() returns undefined.\r\n */\n\n\nconst TurnOrder = {\n  /**\r\n   * DEFAULT\r\n   *\r\n   * The default round-robin turn order.\r\n   */\n  DEFAULT: {\n    first: (G, ctx) => ctx.turn === 0 ? ctx.playOrderPos : (ctx.playOrderPos + 1) % ctx.playOrder.length,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  },\n\n  /**\r\n   * RESET\r\n   *\r\n   * Similar to DEFAULT, but starts from 0 each time.\r\n   */\n  RESET: {\n    first: () => 0,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  },\n\n  /**\r\n   * CONTINUE\r\n   *\r\n   * Similar to DEFAULT, but starts with the player who ended the last phase.\r\n   */\n  CONTINUE: {\n    first: (G, ctx) => ctx.playOrderPos,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  },\n\n  /**\r\n   * ONCE\r\n   *\r\n   * Another round-robin turn order, but goes around just once.\r\n   * The phase ends after all players have played.\r\n   */\n  ONCE: {\n    first: () => 0,\n    next: (G, ctx) => {\n      if (ctx.playOrderPos < ctx.playOrder.length - 1) {\n        return ctx.playOrderPos + 1;\n      }\n    }\n  },\n\n  /**\r\n   * CUSTOM\r\n   *\r\n   * Identical to DEFAULT, but also sets playOrder at the\r\n   * beginning of the phase.\r\n   *\r\n   * @param {Array} playOrder - The play order.\r\n   */\n  CUSTOM: playOrder => ({\n    playOrder: () => playOrder,\n    first: () => 0,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  }),\n\n  /**\r\n   * CUSTOM_FROM\r\n   *\r\n   * Identical to DEFAULT, but also sets playOrder at the\r\n   * beginning of the phase to a value specified by a field\r\n   * in G.\r\n   *\r\n   * @param {string} playOrderField - Field in G.\r\n   */\n  CUSTOM_FROM: playOrderField => ({\n    playOrder: G => G[playOrderField],\n    first: () => 0,\n    next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length\n  })\n};\nconst Stage = {\n  NULL: null\n};\nconst ActivePlayers = {\n  /**\r\n   * ALL\r\n   *\r\n   * The turn stays with one player, but any player can play (in any order)\r\n   * until the phase ends.\r\n   */\n  ALL: {\n    all: Stage.NULL\n  },\n\n  /**\r\n   * ALL_ONCE\r\n   *\r\n   * The turn stays with one player, but any player can play (once, and in any order).\r\n   * This is typically used in a phase where you want to elicit a response\r\n   * from every player in the game.\r\n   */\n  ALL_ONCE: {\n    all: Stage.NULL,\n    minMoves: 1,\n    maxMoves: 1\n  },\n\n  /**\r\n   * OTHERS\r\n   *\r\n   * The turn stays with one player, and every *other* player can play (in any order)\r\n   * until the phase ends.\r\n   */\n  OTHERS: {\n    others: Stage.NULL\n  },\n\n  /**\r\n   * OTHERS_ONCE\r\n   *\r\n   * The turn stays with one player, and every *other* player can play (once, and in any order).\r\n   * This is typically used in a phase where you want to elicit a response\r\n   * from every *other* player in the game.\r\n   */\n  OTHERS_ONCE: {\n    others: Stage.NULL,\n    minMoves: 1,\n    maxMoves: 1\n  }\n};\nexport { ActionCreators as A, makeMove as B, ActivePlayers as C, EnhanceCtx as E, FnWrap as F, GameMethod as G, InitTurnOrderState as I, MAKE_MOVE as M, NoClient as N, PATCH as P, REDO as R, Stage as S, TurnOrder as T, UpdateTurnOrderState as U, supportDeprecatedMoveLimit as a, SetActivePlayers as b, UpdateActivePlayersOnceEmpty as c, PLUGIN as d, error as e, ProcessAction as f, gameEvent as g, UNDO as h, info as i, SYNC as j, UPDATE as k, RESET as l, Enhance as m, INVALID_MOVE as n, GAME_EVENT as o, STRIP_TRANSIENTS as p, FlushAndValidate as q, stripTransients as r, sync as s, Setup as t, reset as u, undo as v, redo as w, PlayerView as x, patch as y, update as z };","map":{"version":3,"sources":["/Users/andywang/Desktop/CS161_Breadsticks/node_modules/boardgame.io/dist/esm/turn-order-0b7dce3d.js"],"names":["produce","R","RandomPlugin","isPlainObject","MAKE_MOVE","GAME_EVENT","REDO","RESET","SYNC","UNDO","UPDATE","PATCH","PLUGIN","STRIP_TRANSIENTS","makeMove","type","args","playerID","credentials","payload","gameEvent","automaticGameEvent","automatic","sync","info","state","log","initialState","clientOnly","patch","prevStateID","stateID","deltalog","update","reset","undo","redo","plugin","stripTransients","ActionCreators","Object","freeze","__proto__","INVALID_MOVE","ImmerPlugin","name","fnWrap","move","G","ctx","isInvalid","newG","result","GameMethod","Errors","Events","constructor","flow","dispatch","initialTurn","turn","updateTurnContext","undefined","maxEndedTurnsPerAction","numPlayers","api","events","_private","eventNames","push","phase","currentPhase","currentTurn","calledFrom","currentMethod","error","Error","isUsed","length","methodType","unsetCurrentMethod","stateWithError","message","stack","plugins","data","EventQueue","i","event","turnHasEnded","endedTurns","MaxTurnEndings","CalledOutsideHook","gameover","TURN_ON_END","PHASE_ON_END","StageEventInOnEnd","PHASE_ON_BEGIN","StageEventInPhaseBegin","TURN_ON_BEGIN","StageEventInTurnBegin","EndTurnInOnEnd","PhaseEventInOnEnd","action","processEvent","EventsPlugin","noClient","method","dangerouslyFlushRawState","game","LogPlugin","flush","setMetadata","metadata","setup","isSerializable","value","Array","isArray","key","SerializablePlugin","process","env","NODE_ENV","production","logfn","console","errorfn","msg","CORE_PLUGINS","DEFAULT_PLUGINS","ProcessAction","opts","filter","forEach","pluginState","EnhanceCtx","entries","FnWrap","methodToWrap","reduce","Setup","Enhance","Flush","reverse","newData","NoClient","map","includes","IsInvalid","firstInvalidReturn","find","FlushAndValidate","updatedState","PlayerView","playerView","supportDeprecatedMoveLimit","options","enforceMinMoves","moveLimit","minMoves","maxMoves","SetActivePlayers","arg","activePlayers","_prevActivePlayers","_nextActivePlayers","_activePlayersMinMoves","_activePlayersMaxMoves","v","Stage","NULL","next","revert","_activePlayersNumMoves","currentPlayer","ApplyActivePlayerArgument","others","playOrder","id","all","keys","UpdateActivePlayersOnceEmpty","lastIndex","slice","stage","getCurrentPlayer","playOrderPos","InitTurnOrderState","ctxWithAPI","order","from","_","first","posType","UpdateTurnOrderState","endTurnArg","endPhase","indexOf","t","TurnOrder","DEFAULT","CONTINUE","ONCE","CUSTOM","CUSTOM_FROM","playOrderField","ActivePlayers","ALL","ALL_ONCE","OTHERS","OTHERS_ONCE","A","B","C","E","F","I","M","N","P","S","T","U","a","b","c","d","e","f","g","h","j","k","l","m","n","o","p","q","r","s","u","w","x","y","z"],"mappings":"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","sourcesContent":["import produce from 'immer';\nimport { R as RandomPlugin } from './plugin-random-087f861e.js';\nimport isPlainObject from 'lodash.isplainobject';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst MAKE_MOVE = 'MAKE_MOVE';\r\nconst GAME_EVENT = 'GAME_EVENT';\r\nconst REDO = 'REDO';\r\nconst RESET = 'RESET';\r\nconst SYNC = 'SYNC';\r\nconst UNDO = 'UNDO';\r\nconst UPDATE = 'UPDATE';\r\nconst PATCH = 'PATCH';\r\nconst PLUGIN = 'PLUGIN';\r\nconst STRIP_TRANSIENTS = 'STRIP_TRANSIENTS';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Generate a move to be dispatched to the game move reducer.\r\n *\r\n * @param {string} type - The move type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst makeMove = (type, args, playerID, credentials) => ({\r\n    type: MAKE_MOVE,\r\n    payload: { type, args, playerID, credentials },\r\n});\r\n/**\r\n * Generate a game event to be dispatched to the flow reducer.\r\n *\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst gameEvent = (type, args, playerID, credentials) => ({\r\n    type: GAME_EVENT,\r\n    payload: { type, args, playerID, credentials },\r\n});\r\n/**\r\n * Generate an automatic game event that is a side-effect of a move.\r\n * @param {string} type - The event type.\r\n * @param {Array}  args - Additional arguments.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst automaticGameEvent = (type, args, playerID, credentials) => ({\r\n    type: GAME_EVENT,\r\n    payload: { type, args, playerID, credentials },\r\n    automatic: true,\r\n});\r\nconst sync = (info) => ({\r\n    type: SYNC,\r\n    state: info.state,\r\n    log: info.log,\r\n    initialState: info.initialState,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to update the Redux store's state with patch in response to\r\n * an action coming from another player.\r\n * @param prevStateID previous stateID\r\n * @param stateID stateID after this patch\r\n * @param {Operation[]} patch - The patch to apply.\r\n * @param {LogEntry[]} deltalog - A log delta.\r\n */\r\nconst patch = (prevStateID, stateID, patch, deltalog) => ({\r\n    type: PATCH,\r\n    prevStateID,\r\n    stateID,\r\n    patch,\r\n    deltalog,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to update the Redux store's state in response to\r\n * an action coming from another player.\r\n * @param {object} state - The state to restore.\r\n * @param {Array} deltalog - A log delta.\r\n */\r\nconst update = (state, deltalog) => ({\r\n    type: UPDATE,\r\n    state,\r\n    deltalog,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to reset the game state.\r\n * @param {object} state - The initial state.\r\n */\r\nconst reset = (state) => ({\r\n    type: RESET,\r\n    state,\r\n    clientOnly: true,\r\n});\r\n/**\r\n * Used to undo the last move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst undo = (playerID, credentials) => ({\r\n    type: UNDO,\r\n    payload: { type: null, args: null, playerID, credentials },\r\n});\r\n/**\r\n * Used to redo the last undone move.\r\n * @param {string}  playerID - The ID of the player making this action.\r\n * @param {string}  credentials - (optional) The credentials for the player making this action.\r\n */\r\nconst redo = (playerID, credentials) => ({\r\n    type: REDO,\r\n    payload: { type: null, args: null, playerID, credentials },\r\n});\r\n/**\r\n * Allows plugins to define their own actions and intercept them.\r\n */\r\nconst plugin = (type, args, playerID, credentials) => ({\r\n    type: PLUGIN,\r\n    payload: { type, args, playerID, credentials },\r\n});\r\n/**\r\n * Private action used to strip transient metadata (e.g. errors) from the game\r\n * state.\r\n */\r\nconst stripTransients = () => ({\r\n    type: STRIP_TRANSIENTS,\r\n});\n\nvar ActionCreators = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  makeMove: makeMove,\n  gameEvent: gameEvent,\n  automaticGameEvent: automaticGameEvent,\n  sync: sync,\n  patch: patch,\n  update: update,\n  reset: reset,\n  undo: undo,\n  redo: redo,\n  plugin: plugin,\n  stripTransients: stripTransients\n});\n\n/**\r\n * Moves can return this when they want to indicate\r\n * that the combination of arguments is illegal and\r\n * the move ought to be discarded.\r\n */\r\nconst INVALID_MOVE = 'INVALID_MOVE';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Plugin that allows using Immer to make immutable changes\r\n * to G by just mutating it.\r\n */\r\nconst ImmerPlugin = {\r\n    name: 'plugin-immer',\r\n    fnWrap: (move) => (G, ctx, ...args) => {\r\n        let isInvalid = false;\r\n        const newG = produce(G, (G) => {\r\n            const result = move(G, ctx, ...args);\r\n            if (result === INVALID_MOVE) {\r\n                isInvalid = true;\r\n                return;\r\n            }\r\n            return result;\r\n        });\r\n        if (isInvalid)\r\n            return INVALID_MOVE;\r\n        return newG;\r\n    },\r\n};\n\nvar GameMethod;\r\n(function (GameMethod) {\r\n    GameMethod[\"MOVE\"] = \"MOVE\";\r\n    GameMethod[\"GAME_ON_END\"] = \"GAME_ON_END\";\r\n    GameMethod[\"PHASE_ON_BEGIN\"] = \"PHASE_ON_BEGIN\";\r\n    GameMethod[\"PHASE_ON_END\"] = \"PHASE_ON_END\";\r\n    GameMethod[\"TURN_ON_BEGIN\"] = \"TURN_ON_BEGIN\";\r\n    GameMethod[\"TURN_ON_MOVE\"] = \"TURN_ON_MOVE\";\r\n    GameMethod[\"TURN_ON_END\"] = \"TURN_ON_END\";\r\n})(GameMethod || (GameMethod = {}));\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nvar Errors;\r\n(function (Errors) {\r\n    Errors[\"CalledOutsideHook\"] = \"Events must be called from moves or the `onBegin`, `onEnd`, and `onMove` hooks.\\nThis error probably means you called an event from other game code, like an `endIf` trigger or one of the `turn.order` methods.\";\r\n    Errors[\"EndTurnInOnEnd\"] = \"`endTurn` is disallowed in `onEnd` hooks \\u2014 the turn is already ending.\";\r\n    Errors[\"MaxTurnEndings\"] = \"Maximum number of turn endings exceeded for this update.\\nThis likely means game code is triggering an infinite loop.\";\r\n    Errors[\"PhaseEventInOnEnd\"] = \"`setPhase` & `endPhase` are disallowed in a phase\\u2019s `onEnd` hook \\u2014 the phase is already ending.\\nIf you\\u2019re trying to dynamically choose the next phase when a phase ends, use the phase\\u2019s `next` trigger.\";\r\n    Errors[\"StageEventInOnEnd\"] = \"`setStage`, `endStage` & `setActivePlayers` are disallowed in `onEnd` hooks.\";\r\n    Errors[\"StageEventInPhaseBegin\"] = \"`setStage`, `endStage` & `setActivePlayers` are disallowed in a phase\\u2019s `onBegin` hook.\\nUse `setActivePlayers` in a `turn.onBegin` hook or declare stages with `turn.activePlayers` instead.\";\r\n    Errors[\"StageEventInTurnBegin\"] = \"`setStage` & `endStage` are disallowed in `turn.onBegin`.\\nUse `setActivePlayers` or declare stages with `turn.activePlayers` instead.\";\r\n})(Errors || (Errors = {}));\r\n/**\r\n * Events\r\n */\r\nclass Events {\r\n    constructor(flow, ctx, playerID) {\r\n        this.flow = flow;\r\n        this.playerID = playerID;\r\n        this.dispatch = [];\r\n        this.initialTurn = ctx.turn;\r\n        this.updateTurnContext(ctx, undefined);\r\n        // This is an arbitrarily large upper threshold, which could be made\r\n        // configurable via a game option if the need arises.\r\n        this.maxEndedTurnsPerAction = ctx.numPlayers * 100;\r\n    }\r\n    api() {\r\n        const events = {\r\n            _private: this,\r\n        };\r\n        for (const type of this.flow.eventNames) {\r\n            events[type] = (...args) => {\r\n                this.dispatch.push({\r\n                    type,\r\n                    args,\r\n                    phase: this.currentPhase,\r\n                    turn: this.currentTurn,\r\n                    calledFrom: this.currentMethod,\r\n                    // Used to capture a stack trace in case it is needed later.\r\n                    error: new Error('Events Plugin Error'),\r\n                });\r\n            };\r\n        }\r\n        return events;\r\n    }\r\n    isUsed() {\r\n        return this.dispatch.length > 0;\r\n    }\r\n    updateTurnContext(ctx, methodType) {\r\n        this.currentPhase = ctx.phase;\r\n        this.currentTurn = ctx.turn;\r\n        this.currentMethod = methodType;\r\n    }\r\n    unsetCurrentMethod() {\r\n        this.currentMethod = undefined;\r\n    }\r\n    /**\r\n     * Updates ctx with the triggered events.\r\n     * @param {object} state - The state object { G, ctx }.\r\n     */\r\n    update(state) {\r\n        const initialState = state;\r\n        const stateWithError = ({ stack }, message) => ({\r\n            ...initialState,\r\n            plugins: {\r\n                ...initialState.plugins,\r\n                events: {\r\n                    ...initialState.plugins.events,\r\n                    data: { error: message + '\\n' + stack },\r\n                },\r\n            },\r\n        });\r\n        EventQueue: for (let i = 0; i < this.dispatch.length; i++) {\r\n            const event = this.dispatch[i];\r\n            const turnHasEnded = event.turn !== state.ctx.turn;\r\n            // This protects against potential infinite loops if specific events are called on hooks.\r\n            // The moment we exceed the defined threshold, we just bail out of all phases.\r\n            const endedTurns = this.currentTurn - this.initialTurn;\r\n            if (endedTurns >= this.maxEndedTurnsPerAction) {\r\n                return stateWithError(event.error, Errors.MaxTurnEndings);\r\n            }\r\n            if (event.calledFrom === undefined) {\r\n                return stateWithError(event.error, Errors.CalledOutsideHook);\r\n            }\r\n            // Stop processing events once the game has finished.\r\n            if (state.ctx.gameover)\r\n                break EventQueue;\r\n            switch (event.type) {\r\n                case 'endStage':\r\n                case 'setStage':\r\n                case 'setActivePlayers': {\r\n                    switch (event.calledFrom) {\r\n                        // Disallow all stage events in onEnd and phase.onBegin hooks.\r\n                        case GameMethod.TURN_ON_END:\r\n                        case GameMethod.PHASE_ON_END:\r\n                            return stateWithError(event.error, Errors.StageEventInOnEnd);\r\n                        case GameMethod.PHASE_ON_BEGIN:\r\n                            return stateWithError(event.error, Errors.StageEventInPhaseBegin);\r\n                        // Disallow setStage & endStage in turn.onBegin hooks.\r\n                        case GameMethod.TURN_ON_BEGIN:\r\n                            if (event.type === 'setActivePlayers')\r\n                                break;\r\n                            return stateWithError(event.error, Errors.StageEventInTurnBegin);\r\n                    }\r\n                    // If the turn already ended, don't try to process stage events.\r\n                    if (turnHasEnded)\r\n                        continue EventQueue;\r\n                    break;\r\n                }\r\n                case 'endTurn': {\r\n                    if (event.calledFrom === GameMethod.TURN_ON_END ||\r\n                        event.calledFrom === GameMethod.PHASE_ON_END) {\r\n                        return stateWithError(event.error, Errors.EndTurnInOnEnd);\r\n                    }\r\n                    // If the turn already ended some other way,\r\n                    // don't try to end the turn again.\r\n                    if (turnHasEnded)\r\n                        continue EventQueue;\r\n                    break;\r\n                }\r\n                case 'endPhase':\r\n                case 'setPhase': {\r\n                    if (event.calledFrom === GameMethod.PHASE_ON_END) {\r\n                        return stateWithError(event.error, Errors.PhaseEventInOnEnd);\r\n                    }\r\n                    // If the phase already ended some other way,\r\n                    // don't try to end the phase again.\r\n                    if (event.phase !== state.ctx.phase)\r\n                        continue EventQueue;\r\n                    break;\r\n                }\r\n            }\r\n            const action = automaticGameEvent(event.type, event.args, this.playerID);\r\n            state = this.flow.processEvent(state, action);\r\n        }\r\n        return state;\r\n    }\r\n}\n\n/*\r\n * Copyright 2020 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst EventsPlugin = {\r\n    name: 'events',\r\n    noClient: ({ api }) => api._private.isUsed(),\r\n    isInvalid: ({ data }) => data.error || false,\r\n    // Update the events plugin’s internal turn context each time a move\r\n    // or hook is called. This allows events called after turn or phase\r\n    // endings to dispatch the current turn and phase correctly.\r\n    fnWrap: (method, methodType) => (G, ctx, ...args) => {\r\n        const api = ctx.events;\r\n        if (api)\r\n            api._private.updateTurnContext(ctx, methodType);\r\n        G = method(G, ctx, ...args);\r\n        if (api)\r\n            api._private.unsetCurrentMethod();\r\n        return G;\r\n    },\r\n    dangerouslyFlushRawState: ({ state, api }) => api._private.update(state),\r\n    api: ({ game, ctx, playerID }) => new Events(game.flow, ctx, playerID).api(),\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Plugin that makes it possible to add metadata to log entries.\r\n * During a move, you can set metadata using ctx.log.setMetadata and it will be\r\n * available on the log entry for that move.\r\n */\r\nconst LogPlugin = {\r\n    name: 'log',\r\n    flush: () => ({}),\r\n    api: ({ data }) => {\r\n        return {\r\n            setMetadata: (metadata) => {\r\n                data.metadata = metadata;\r\n            },\r\n        };\r\n    },\r\n    setup: () => ({}),\r\n};\n\n/**\r\n * Check if a value can be serialized (e.g. using `JSON.stringify`).\r\n * Adapted from: https://stackoverflow.com/a/30712764/3829557\r\n */\r\nfunction isSerializable(value) {\r\n    // Primitives are OK.\r\n    if (value === undefined ||\r\n        value === null ||\r\n        typeof value === 'boolean' ||\r\n        typeof value === 'number' ||\r\n        typeof value === 'string') {\r\n        return true;\r\n    }\r\n    // A non-primitive value that is neither a POJO or an array cannot be serialized.\r\n    if (!isPlainObject(value) && !Array.isArray(value)) {\r\n        return false;\r\n    }\r\n    // Recurse entries if the value is an object or array.\r\n    for (const key in value) {\r\n        if (!isSerializable(value[key]))\r\n            return false;\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Plugin that checks whether state is serializable, in order to avoid\r\n * network serialization bugs.\r\n */\r\nconst SerializablePlugin = {\r\n    name: 'plugin-serializable',\r\n    fnWrap: (move) => (G, ctx, ...args) => {\r\n        const result = move(G, ctx, ...args);\r\n        // Check state in non-production environments.\r\n        if (process.env.NODE_ENV !== 'production' && !isSerializable(result)) {\r\n            throw new Error('Move state is not JSON-serialiazable.\\n' +\r\n                'See https://boardgame.io/documentation/#/?id=state for more information.');\r\n        }\r\n        return result;\r\n    },\r\n};\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst production = process.env.NODE_ENV === 'production';\r\nconst logfn = production ? () => { } : (...msg) => console.log(...msg);\r\nconst errorfn = (...msg) => console.error(...msg);\r\nfunction info(msg) {\r\n    logfn(`INFO: ${msg}`);\r\n}\r\nfunction error(error) {\r\n    errorfn('ERROR:', error);\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * List of plugins that are always added.\r\n */\r\nconst CORE_PLUGINS = [ImmerPlugin, RandomPlugin, LogPlugin, SerializablePlugin];\r\nconst DEFAULT_PLUGINS = [...CORE_PLUGINS, EventsPlugin];\r\n/**\r\n * Allow plugins to intercept actions and process them.\r\n */\r\nconst ProcessAction = (state, action, opts) => {\r\n    // TODO(#723): Extend error handling to plugins.\r\n    opts.game.plugins\r\n        .filter((plugin) => plugin.action !== undefined)\r\n        .filter((plugin) => plugin.name === action.payload.type)\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name] || { data: {} };\r\n        const data = plugin.action(pluginState.data, action.payload);\r\n        state = {\r\n            ...state,\r\n            plugins: {\r\n                ...state.plugins,\r\n                [name]: { ...pluginState, data },\r\n            },\r\n        };\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * The API's created by various plugins are stored in the plugins\r\n * section of the state object:\r\n *\r\n * {\r\n *   G: {},\r\n *   ctx: {},\r\n *   plugins: {\r\n *     plugin-a: {\r\n *       data: {},  // this is generated by the plugin at Setup / Flush.\r\n *       api: {},   // this is ephemeral and generated by Enhance.\r\n *     }\r\n *   }\r\n * }\r\n *\r\n * This function takes these API's and stuffs them back into\r\n * ctx for consumption inside a move function or hook.\r\n */\r\nconst EnhanceCtx = (state) => {\r\n    const ctx = { ...state.ctx };\r\n    const plugins = state.plugins || {};\r\n    Object.entries(plugins).forEach(([name, { api }]) => {\r\n        ctx[name] = api;\r\n    });\r\n    return ctx;\r\n};\r\n/**\r\n * Applies the provided plugins to the given move / flow function.\r\n *\r\n * @param methodToWrap - The move function or hook to apply the plugins to.\r\n * @param methodType - The type of the move or hook being wrapped.\r\n * @param plugins - The list of plugins.\r\n */\r\nconst FnWrap = (methodToWrap, methodType, plugins) => {\r\n    return [...CORE_PLUGINS, ...plugins, EventsPlugin]\r\n        .filter((plugin) => plugin.fnWrap !== undefined)\r\n        .reduce((method, { fnWrap }) => fnWrap(method, methodType), methodToWrap);\r\n};\r\n/**\r\n * Allows the plugin to generate its initial state.\r\n */\r\nconst Setup = (state, opts) => {\r\n    [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.setup !== undefined)\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const data = plugin.setup({\r\n            G: state.G,\r\n            ctx: state.ctx,\r\n            game: opts.game,\r\n        });\r\n        state = {\r\n            ...state,\r\n            plugins: {\r\n                ...state.plugins,\r\n                [name]: { data },\r\n            },\r\n        };\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * Invokes the plugin before a move or event.\r\n * The API that the plugin generates is stored inside\r\n * the `plugins` section of the state (which is subsequently\r\n * merged into ctx).\r\n */\r\nconst Enhance = (state, opts) => {\r\n    [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.api !== undefined)\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name] || { data: {} };\r\n        const api = plugin.api({\r\n            G: state.G,\r\n            ctx: state.ctx,\r\n            data: pluginState.data,\r\n            game: opts.game,\r\n            playerID: opts.playerID,\r\n        });\r\n        state = {\r\n            ...state,\r\n            plugins: {\r\n                ...state.plugins,\r\n                [name]: { ...pluginState, api },\r\n            },\r\n        };\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * Allows plugins to update their state after a move / event.\r\n */\r\nconst Flush = (state, opts) => {\r\n    // We flush the events plugin first, then custom plugins and the core plugins.\r\n    // This means custom plugins cannot use the events API but will be available in event hooks.\r\n    // Note that plugins are flushed in reverse, to allow custom plugins calling each other.\r\n    [...CORE_PLUGINS, ...opts.game.plugins, EventsPlugin]\r\n        .reverse()\r\n        .forEach((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name] || { data: {} };\r\n        if (plugin.flush) {\r\n            const newData = plugin.flush({\r\n                G: state.G,\r\n                ctx: state.ctx,\r\n                game: opts.game,\r\n                api: pluginState.api,\r\n                data: pluginState.data,\r\n            });\r\n            state = {\r\n                ...state,\r\n                plugins: {\r\n                    ...state.plugins,\r\n                    [plugin.name]: { data: newData },\r\n                },\r\n            };\r\n        }\r\n        else if (plugin.dangerouslyFlushRawState) {\r\n            state = plugin.dangerouslyFlushRawState({\r\n                state,\r\n                game: opts.game,\r\n                api: pluginState.api,\r\n                data: pluginState.data,\r\n            });\r\n            // Remove everything other than data.\r\n            const data = state.plugins[name].data;\r\n            state = {\r\n                ...state,\r\n                plugins: {\r\n                    ...state.plugins,\r\n                    [plugin.name]: { data },\r\n                },\r\n            };\r\n        }\r\n    });\r\n    return state;\r\n};\r\n/**\r\n * Allows plugins to indicate if they should not be materialized on the client.\r\n * This will cause the client to discard the state update and wait for the\r\n * master instead.\r\n */\r\nconst NoClient = (state, opts) => {\r\n    return [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.noClient !== undefined)\r\n        .map((plugin) => {\r\n        const name = plugin.name;\r\n        const pluginState = state.plugins[name];\r\n        if (pluginState) {\r\n            return plugin.noClient({\r\n                G: state.G,\r\n                ctx: state.ctx,\r\n                game: opts.game,\r\n                api: pluginState.api,\r\n                data: pluginState.data,\r\n            });\r\n        }\r\n        return false;\r\n    })\r\n        .includes(true);\r\n};\r\n/**\r\n * Allows plugins to indicate if the entire action should be thrown out\r\n * as invalid. This will cancel the entire state update.\r\n */\r\nconst IsInvalid = (state, opts) => {\r\n    const firstInvalidReturn = [...DEFAULT_PLUGINS, ...opts.game.plugins]\r\n        .filter((plugin) => plugin.isInvalid !== undefined)\r\n        .map((plugin) => {\r\n        const { name } = plugin;\r\n        const pluginState = state.plugins[name];\r\n        const message = plugin.isInvalid({\r\n            G: state.G,\r\n            ctx: state.ctx,\r\n            game: opts.game,\r\n            data: pluginState && pluginState.data,\r\n        });\r\n        return message ? { plugin: name, message } : false;\r\n    })\r\n        .find((value) => value);\r\n    return firstInvalidReturn || false;\r\n};\r\n/**\r\n * Update plugin state after move/event & check if plugins consider the update to be valid.\r\n * @returns Tuple of `[updatedState]` or `[originalState, invalidError]`.\r\n */\r\nconst FlushAndValidate = (state, opts) => {\r\n    const updatedState = Flush(state, opts);\r\n    const isInvalid = IsInvalid(updatedState, opts);\r\n    if (!isInvalid)\r\n        return [updatedState];\r\n    const { plugin, message } = isInvalid;\r\n    error(`${plugin} plugin declared action invalid:\\n${message}`);\r\n    return [state, isInvalid];\r\n};\r\n/**\r\n * Allows plugins to customize their data for specific players.\r\n * For example, a plugin may want to share no data with the client, or\r\n * want to keep some player data secret from opponents.\r\n */\r\nconst PlayerView = ({ G, ctx, plugins = {} }, { game, playerID }) => {\r\n    [...DEFAULT_PLUGINS, ...game.plugins].forEach(({ name, playerView }) => {\r\n        if (!playerView)\r\n            return;\r\n        const { data } = plugins[name] || { data: {} };\r\n        const newData = playerView({ G, ctx, game, data, playerID });\r\n        plugins = {\r\n            ...plugins,\r\n            [name]: { data: newData },\r\n        };\r\n    });\r\n    return plugins;\r\n};\n\n/**\r\n * Adjust the given options to use the new minMoves/maxMoves if a legacy moveLimit was given\r\n * @param options The options object to apply backwards compatibility to\r\n * @param enforceMinMoves Use moveLimit to set both minMoves and maxMoves\r\n */\r\nfunction supportDeprecatedMoveLimit(options, enforceMinMoves = false) {\r\n    if (options.moveLimit) {\r\n        if (enforceMinMoves) {\r\n            options.minMoves = options.moveLimit;\r\n        }\r\n        options.maxMoves = options.moveLimit;\r\n        delete options.moveLimit;\r\n    }\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nfunction SetActivePlayers(ctx, arg) {\r\n    let activePlayers = {};\r\n    let _prevActivePlayers = [];\r\n    let _nextActivePlayers = null;\r\n    let _activePlayersMinMoves = {};\r\n    let _activePlayersMaxMoves = {};\r\n    if (Array.isArray(arg)) {\r\n        // support a simple array of player IDs as active players\r\n        const value = {};\r\n        arg.forEach((v) => (value[v] = Stage.NULL));\r\n        activePlayers = value;\r\n    }\r\n    else {\r\n        // process active players argument object\r\n        // stages previously did not enforce minMoves, this behaviour is kept intentionally\r\n        supportDeprecatedMoveLimit(arg);\r\n        if (arg.next) {\r\n            _nextActivePlayers = arg.next;\r\n        }\r\n        if (arg.revert) {\r\n            _prevActivePlayers = [\r\n                ...ctx._prevActivePlayers,\r\n                {\r\n                    activePlayers: ctx.activePlayers,\r\n                    _activePlayersMinMoves: ctx._activePlayersMinMoves,\r\n                    _activePlayersMaxMoves: ctx._activePlayersMaxMoves,\r\n                    _activePlayersNumMoves: ctx._activePlayersNumMoves,\r\n                },\r\n            ];\r\n        }\r\n        if (arg.currentPlayer !== undefined) {\r\n            ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, ctx.currentPlayer, arg.currentPlayer);\r\n        }\r\n        if (arg.others !== undefined) {\r\n            for (let i = 0; i < ctx.playOrder.length; i++) {\r\n                const id = ctx.playOrder[i];\r\n                if (id !== ctx.currentPlayer) {\r\n                    ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.others);\r\n                }\r\n            }\r\n        }\r\n        if (arg.all !== undefined) {\r\n            for (let i = 0; i < ctx.playOrder.length; i++) {\r\n                const id = ctx.playOrder[i];\r\n                ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.all);\r\n            }\r\n        }\r\n        if (arg.value) {\r\n            for (const id in arg.value) {\r\n                ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, id, arg.value[id]);\r\n            }\r\n        }\r\n        if (arg.minMoves) {\r\n            for (const id in activePlayers) {\r\n                if (_activePlayersMinMoves[id] === undefined) {\r\n                    _activePlayersMinMoves[id] = arg.minMoves;\r\n                }\r\n            }\r\n        }\r\n        if (arg.maxMoves) {\r\n            for (const id in activePlayers) {\r\n                if (_activePlayersMaxMoves[id] === undefined) {\r\n                    _activePlayersMaxMoves[id] = arg.maxMoves;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (Object.keys(activePlayers).length === 0) {\r\n        activePlayers = null;\r\n    }\r\n    if (Object.keys(_activePlayersMinMoves).length === 0) {\r\n        _activePlayersMinMoves = null;\r\n    }\r\n    if (Object.keys(_activePlayersMaxMoves).length === 0) {\r\n        _activePlayersMaxMoves = null;\r\n    }\r\n    const _activePlayersNumMoves = {};\r\n    for (const id in activePlayers) {\r\n        _activePlayersNumMoves[id] = 0;\r\n    }\r\n    return {\r\n        ...ctx,\r\n        activePlayers,\r\n        _activePlayersMinMoves,\r\n        _activePlayersMaxMoves,\r\n        _activePlayersNumMoves,\r\n        _prevActivePlayers,\r\n        _nextActivePlayers,\r\n    };\r\n}\r\n/**\r\n * Update activePlayers, setting it to previous, next or null values\r\n * when it becomes empty.\r\n * @param ctx\r\n */\r\nfunction UpdateActivePlayersOnceEmpty(ctx) {\r\n    let { activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, _activePlayersNumMoves, _prevActivePlayers, _nextActivePlayers, } = ctx;\r\n    if (activePlayers && Object.keys(activePlayers).length === 0) {\r\n        if (_nextActivePlayers) {\r\n            ctx = SetActivePlayers(ctx, _nextActivePlayers);\r\n            ({\r\n                activePlayers,\r\n                _activePlayersMinMoves,\r\n                _activePlayersMaxMoves,\r\n                _activePlayersNumMoves,\r\n                _prevActivePlayers,\r\n            } = ctx);\r\n        }\r\n        else if (_prevActivePlayers.length > 0) {\r\n            const lastIndex = _prevActivePlayers.length - 1;\r\n            ({\r\n                activePlayers,\r\n                _activePlayersMinMoves,\r\n                _activePlayersMaxMoves,\r\n                _activePlayersNumMoves,\r\n            } = _prevActivePlayers[lastIndex]);\r\n            _prevActivePlayers = _prevActivePlayers.slice(0, lastIndex);\r\n        }\r\n        else {\r\n            activePlayers = null;\r\n            _activePlayersMinMoves = null;\r\n            _activePlayersMaxMoves = null;\r\n        }\r\n    }\r\n    return {\r\n        ...ctx,\r\n        activePlayers,\r\n        _activePlayersMinMoves,\r\n        _activePlayersMaxMoves,\r\n        _activePlayersNumMoves,\r\n        _prevActivePlayers,\r\n    };\r\n}\r\n/**\r\n * Apply an active player argument to the given player ID\r\n * @param {Object} activePlayers\r\n * @param {Object} _activePlayersMinMoves\r\n * @param {Object} _activePlayersMaxMoves\r\n * @param {String} playerID The player to apply the parameter to\r\n * @param {(String|Object)} arg An active player argument\r\n */\r\nfunction ApplyActivePlayerArgument(activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, playerID, arg) {\r\n    if (typeof arg !== 'object' || arg === Stage.NULL) {\r\n        arg = { stage: arg };\r\n    }\r\n    if (arg.stage !== undefined) {\r\n        // stages previously did not enforce minMoves, this behaviour is kept intentionally\r\n        supportDeprecatedMoveLimit(arg);\r\n        activePlayers[playerID] = arg.stage;\r\n        if (arg.minMoves)\r\n            _activePlayersMinMoves[playerID] = arg.minMoves;\r\n        if (arg.maxMoves)\r\n            _activePlayersMaxMoves[playerID] = arg.maxMoves;\r\n    }\r\n}\r\n/**\r\n * Converts a playOrderPos index into its value in playOrder.\r\n * @param {Array} playOrder - An array of player ID's.\r\n * @param {number} playOrderPos - An index into the above.\r\n */\r\nfunction getCurrentPlayer(playOrder, playOrderPos) {\r\n    // convert to string in case playOrder is set to number[]\r\n    return playOrder[playOrderPos] + '';\r\n}\r\n/**\r\n * Called at the start of a turn to initialize turn order state.\r\n *\r\n * TODO: This is called inside StartTurn, which is called from\r\n * both UpdateTurn and StartPhase (so it's called at the beginning\r\n * of a new phase as well as between turns). We should probably\r\n * split it into two.\r\n */\r\nfunction InitTurnOrderState(state, turn) {\r\n    let { G, ctx } = state;\r\n    const { numPlayers } = ctx;\r\n    const ctxWithAPI = EnhanceCtx(state);\r\n    const order = turn.order;\r\n    let playOrder = [...Array.from({ length: numPlayers })].map((_, i) => i + '');\r\n    if (order.playOrder !== undefined) {\r\n        playOrder = order.playOrder(G, ctxWithAPI);\r\n    }\r\n    const playOrderPos = order.first(G, ctxWithAPI);\r\n    const posType = typeof playOrderPos;\r\n    if (posType !== 'number') {\r\n        error(`invalid value returned by turn.order.first — expected number got ${posType} “${playOrderPos}”.`);\r\n    }\r\n    const currentPlayer = getCurrentPlayer(playOrder, playOrderPos);\r\n    ctx = { ...ctx, currentPlayer, playOrderPos, playOrder };\r\n    ctx = SetActivePlayers(ctx, turn.activePlayers || {});\r\n    return ctx;\r\n}\r\n/**\r\n * Called at the end of each turn to update the turn order state.\r\n * @param {object} G - The game object G.\r\n * @param {object} ctx - The game object ctx.\r\n * @param {object} turn - A turn object for this phase.\r\n * @param {string} endTurnArg - An optional argument to endTurn that\r\n                                may specify the next player.\r\n */\r\nfunction UpdateTurnOrderState(state, currentPlayer, turn, endTurnArg) {\r\n    const order = turn.order;\r\n    let { G, ctx } = state;\r\n    let playOrderPos = ctx.playOrderPos;\r\n    let endPhase = false;\r\n    if (endTurnArg && endTurnArg !== true) {\r\n        if (typeof endTurnArg !== 'object') {\r\n            error(`invalid argument to endTurn: ${endTurnArg}`);\r\n        }\r\n        Object.keys(endTurnArg).forEach((arg) => {\r\n            switch (arg) {\r\n                case 'remove':\r\n                    currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\r\n                    break;\r\n                case 'next':\r\n                    playOrderPos = ctx.playOrder.indexOf(endTurnArg.next);\r\n                    currentPlayer = endTurnArg.next;\r\n                    break;\r\n                default:\r\n                    error(`invalid argument to endTurn: ${arg}`);\r\n            }\r\n        });\r\n    }\r\n    else {\r\n        const ctxWithAPI = EnhanceCtx(state);\r\n        const t = order.next(G, ctxWithAPI);\r\n        const type = typeof t;\r\n        if (t !== undefined && type !== 'number') {\r\n            error(`invalid value returned by turn.order.next — expected number or undefined got ${type} “${t}”.`);\r\n        }\r\n        if (t === undefined) {\r\n            endPhase = true;\r\n        }\r\n        else {\r\n            playOrderPos = t;\r\n            currentPlayer = getCurrentPlayer(ctx.playOrder, playOrderPos);\r\n        }\r\n    }\r\n    ctx = {\r\n        ...ctx,\r\n        playOrderPos,\r\n        currentPlayer,\r\n    };\r\n    return { endPhase, ctx };\r\n}\r\n/**\r\n * Set of different turn orders possible in a phase.\r\n * These are meant to be passed to the `turn` setting\r\n * in the flow objects.\r\n *\r\n * Each object defines the first player when the phase / game\r\n * begins, and also a function `next` to determine who the\r\n * next player is when the turn ends.\r\n *\r\n * The phase ends if next() returns undefined.\r\n */\r\nconst TurnOrder = {\r\n    /**\r\n     * DEFAULT\r\n     *\r\n     * The default round-robin turn order.\r\n     */\r\n    DEFAULT: {\r\n        first: (G, ctx) => ctx.turn === 0\r\n            ? ctx.playOrderPos\r\n            : (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    },\r\n    /**\r\n     * RESET\r\n     *\r\n     * Similar to DEFAULT, but starts from 0 each time.\r\n     */\r\n    RESET: {\r\n        first: () => 0,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    },\r\n    /**\r\n     * CONTINUE\r\n     *\r\n     * Similar to DEFAULT, but starts with the player who ended the last phase.\r\n     */\r\n    CONTINUE: {\r\n        first: (G, ctx) => ctx.playOrderPos,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    },\r\n    /**\r\n     * ONCE\r\n     *\r\n     * Another round-robin turn order, but goes around just once.\r\n     * The phase ends after all players have played.\r\n     */\r\n    ONCE: {\r\n        first: () => 0,\r\n        next: (G, ctx) => {\r\n            if (ctx.playOrderPos < ctx.playOrder.length - 1) {\r\n                return ctx.playOrderPos + 1;\r\n            }\r\n        },\r\n    },\r\n    /**\r\n     * CUSTOM\r\n     *\r\n     * Identical to DEFAULT, but also sets playOrder at the\r\n     * beginning of the phase.\r\n     *\r\n     * @param {Array} playOrder - The play order.\r\n     */\r\n    CUSTOM: (playOrder) => ({\r\n        playOrder: () => playOrder,\r\n        first: () => 0,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    }),\r\n    /**\r\n     * CUSTOM_FROM\r\n     *\r\n     * Identical to DEFAULT, but also sets playOrder at the\r\n     * beginning of the phase to a value specified by a field\r\n     * in G.\r\n     *\r\n     * @param {string} playOrderField - Field in G.\r\n     */\r\n    CUSTOM_FROM: (playOrderField) => ({\r\n        playOrder: (G) => G[playOrderField],\r\n        first: () => 0,\r\n        next: (G, ctx) => (ctx.playOrderPos + 1) % ctx.playOrder.length,\r\n    }),\r\n};\r\nconst Stage = {\r\n    NULL: null,\r\n};\r\nconst ActivePlayers = {\r\n    /**\r\n     * ALL\r\n     *\r\n     * The turn stays with one player, but any player can play (in any order)\r\n     * until the phase ends.\r\n     */\r\n    ALL: { all: Stage.NULL },\r\n    /**\r\n     * ALL_ONCE\r\n     *\r\n     * The turn stays with one player, but any player can play (once, and in any order).\r\n     * This is typically used in a phase where you want to elicit a response\r\n     * from every player in the game.\r\n     */\r\n    ALL_ONCE: { all: Stage.NULL, minMoves: 1, maxMoves: 1 },\r\n    /**\r\n     * OTHERS\r\n     *\r\n     * The turn stays with one player, and every *other* player can play (in any order)\r\n     * until the phase ends.\r\n     */\r\n    OTHERS: { others: Stage.NULL },\r\n    /**\r\n     * OTHERS_ONCE\r\n     *\r\n     * The turn stays with one player, and every *other* player can play (once, and in any order).\r\n     * This is typically used in a phase where you want to elicit a response\r\n     * from every *other* player in the game.\r\n     */\r\n    OTHERS_ONCE: { others: Stage.NULL, minMoves: 1, maxMoves: 1 },\r\n};\n\nexport { ActionCreators as A, makeMove as B, ActivePlayers as C, EnhanceCtx as E, FnWrap as F, GameMethod as G, InitTurnOrderState as I, MAKE_MOVE as M, NoClient as N, PATCH as P, REDO as R, Stage as S, TurnOrder as T, UpdateTurnOrderState as U, supportDeprecatedMoveLimit as a, SetActivePlayers as b, UpdateActivePlayersOnceEmpty as c, PLUGIN as d, error as e, ProcessAction as f, gameEvent as g, UNDO as h, info as i, SYNC as j, UPDATE as k, RESET as l, Enhance as m, INVALID_MOVE as n, GAME_EVENT as o, STRIP_TRANSIENTS as p, FlushAndValidate as q, stripTransients as r, sync as s, Setup as t, reset as u, undo as v, redo as w, PlayerView as x, patch as y, update as z };\n"]},"metadata":{},"sourceType":"module"}