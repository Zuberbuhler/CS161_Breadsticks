{"ast":null,"code":"const assertString = (str, label) => {\n  if (!str || typeof str !== 'string') {\n    throw new Error(`Expected ${label} string, got \"${str}\".`);\n  }\n};\n\nconst assertGameName = name => assertString(name, 'game name');\n\nconst assertMatchID = id => assertString(id, 'match ID');\n\nconst validateBody = (body, schema) => {\n  if (!body) throw new Error(`Expected body, got “${body}”.`);\n\n  for (const key in schema) {\n    const propSchema = schema[key];\n    const types = Array.isArray(propSchema) ? propSchema : [propSchema];\n    const received = body[key];\n\n    if (!types.includes(typeof received)) {\n      const union = types.join('|');\n      throw new TypeError(`Expected body.${key} to be of type ${union}, got “${received}”.`);\n    }\n  }\n};\n\nclass LobbyClientError extends Error {\n  constructor(message, details) {\n    super(message);\n    this.details = details;\n  }\n\n}\n/**\r\n * Create a boardgame.io Lobby API client.\r\n * @param server The API’s base URL, e.g. `http://localhost:8000`.\r\n */\n\n\nclass LobbyClient {\n  constructor() {\n    let {\n      server = ''\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    // strip trailing slash if passed\n    this.server = server.replace(/\\/$/, '');\n  }\n\n  async request(route, init) {\n    const response = await fetch(this.server + route, init);\n\n    if (!response.ok) {\n      let details;\n\n      try {\n        details = await response.clone().json();\n      } catch {\n        try {\n          details = await response.text();\n        } catch (error) {\n          details = error.message;\n        }\n      }\n\n      throw new LobbyClientError(`HTTP status ${response.status}`, details);\n    }\n\n    return response.json();\n  }\n\n  async post(route, opts) {\n    let init = {\n      method: 'post',\n      body: JSON.stringify(opts.body),\n      headers: {\n        'Content-Type': 'application/json'\n      }\n    };\n    if (opts.init) init = { ...init,\n      ...opts.init,\n      headers: { ...init.headers,\n        ...opts.init.headers\n      }\n    };\n    return this.request(route, init);\n  }\n  /**\r\n   * Get a list of the game names available on this server.\r\n   * @param  init Optional RequestInit interface to override defaults.\r\n   * @return Array of game names.\r\n   *\r\n   * @example\r\n   * lobbyClient.listGames()\r\n   *   .then(console.log); // => ['chess', 'tic-tac-toe']\r\n   */\n\n\n  async listGames(init) {\n    return this.request('/games', init);\n  }\n  /**\r\n   * Get a list of the matches for a specific game type on the server.\r\n   * @param  gameName The game to list for, e.g. 'tic-tac-toe'.\r\n   * @param  where    Options to filter matches by update time or gameover state\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return Array of match metadata objects.\r\n   *\r\n   * @example\r\n   * lobbyClient.listMatches('tic-tac-toe', where: { isGameover: false })\r\n   *   .then(data => console.log(data.matches));\r\n   * // => [\r\n   * //   {\r\n   * //     matchID: 'xyz',\r\n   * //     gameName: 'tic-tac-toe',\r\n   * //     players: [{ id: 0, name: 'Alice' }, { id: 1 }]\r\n   * //   },\r\n   * //   ...\r\n   * // ]\r\n   */\n\n\n  async listMatches(gameName, where, init) {\n    assertGameName(gameName);\n    let query = '';\n\n    if (where) {\n      const queries = [];\n      const {\n        isGameover,\n        updatedBefore,\n        updatedAfter\n      } = where;\n      if (isGameover !== undefined) queries.push(`isGameover=${isGameover}`);\n      if (updatedBefore) queries.push(`updatedBefore=${updatedBefore}`);\n      if (updatedAfter) queries.push(`updatedAfter=${updatedAfter}`);\n      if (queries.length > 0) query = '?' + queries.join('&');\n    }\n\n    return this.request(`/games/${gameName}${query}`, init);\n  }\n  /**\r\n   * Get metadata for a specific match.\r\n   * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n   * @param  matchID  Match ID for the match to fetch.\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return A match metadata object.\r\n   *\r\n   * @example\r\n   * lobbyClient.getMatch('tic-tac-toe', 'xyz').then(console.log);\r\n   * // => {\r\n   * //   matchID: 'xyz',\r\n   * //   gameName: 'tic-tac-toe',\r\n   * //   players: [{ id: 0, name: 'Alice' }, { id: 1 }]\r\n   * // }\r\n   */\n\n\n  async getMatch(gameName, matchID, init) {\n    assertGameName(gameName);\n    assertMatchID(matchID);\n    return this.request(`/games/${gameName}/${matchID}`, init);\n  }\n  /**\r\n   * Create a new match for a specific game type.\r\n   * @param  gameName The game to create a match for, e.g. 'tic-tac-toe'.\r\n   * @param  body     Options required to configure match creation.\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return An object containing the created `matchID`.\r\n   *\r\n   * @example\r\n   * lobbyClient.createMatch('tic-tac-toe', { numPlayers: 2 })\r\n   *   .then(console.log);\r\n   * // => { matchID: 'xyz' }\r\n   */\n\n\n  async createMatch(gameName, body, init) {\n    assertGameName(gameName);\n    validateBody(body, {\n      numPlayers: 'number'\n    });\n    return this.post(`/games/${gameName}/create`, {\n      body,\n      init\n    });\n  }\n  /**\r\n   * Join a match using its matchID.\r\n   * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n   * @param  matchID  Match ID for the match to join.\r\n   * @param  body     Options required to join match.\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return Object containing `playerCredentials` for the player who joined.\r\n   *\r\n   * @example\r\n   * lobbyClient.joinMatch('tic-tac-toe', 'xyz', {\r\n   *   playerID: '1',\r\n   *   playerName: 'Bob',\r\n   * }).then(console.log);\r\n   * // => { playerID: '1', playerCredentials: 'random-string' }\r\n   */\n\n\n  async joinMatch(gameName, matchID, body, init) {\n    assertGameName(gameName);\n    assertMatchID(matchID);\n    validateBody(body, {\n      playerID: ['string', 'undefined'],\n      playerName: 'string'\n    });\n    return this.post(`/games/${gameName}/${matchID}/join`, {\n      body,\n      init\n    });\n  }\n  /**\r\n   * Leave a previously joined match.\r\n   * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n   * @param  matchID  Match ID for the match to leave.\r\n   * @param  body     Options required to leave match.\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return Promise resolves if successful.\r\n   *\r\n   * @example\r\n   * lobbyClient.leaveMatch('tic-tac-toe', 'xyz', {\r\n   *   playerID: '1',\r\n   *   credentials: 'credentials-returned-when-joining',\r\n   * })\r\n   *   .then(() => console.log('Left match.'))\r\n   *   .catch(error => console.error('Error leaving match', error));\r\n   */\n\n\n  async leaveMatch(gameName, matchID, body, init) {\n    assertGameName(gameName);\n    assertMatchID(matchID);\n    validateBody(body, {\n      playerID: 'string',\n      credentials: 'string'\n    });\n    await this.post(`/games/${gameName}/${matchID}/leave`, {\n      body,\n      init\n    });\n  }\n  /**\r\n   * Update a player’s name or custom metadata.\r\n   * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n   * @param  matchID  Match ID for the match to update.\r\n   * @param  body     Options required to update player.\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return Promise resolves if successful.\r\n   *\r\n   * @example\r\n   * lobbyClient.updatePlayer('tic-tac-toe', 'xyz', {\r\n   *   playerID: '0',\r\n   *   credentials: 'credentials-returned-when-joining',\r\n   *   newName: 'Al',\r\n   * })\r\n   *   .then(() => console.log('Updated player data.'))\r\n   *   .catch(error => console.error('Error updating data', error));\r\n   */\n\n\n  async updatePlayer(gameName, matchID, body, init) {\n    assertGameName(gameName);\n    assertMatchID(matchID);\n    validateBody(body, {\n      playerID: 'string',\n      credentials: 'string'\n    });\n    await this.post(`/games/${gameName}/${matchID}/update`, {\n      body,\n      init\n    });\n  }\n  /**\r\n   * Create a new match based on the configuration of the current match.\r\n   * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n   * @param  matchID  Match ID for the match to play again.\r\n   * @param  body     Options required to configure match.\r\n   * @param  init     Optional RequestInit interface to override defaults.\r\n   * @return Object containing `nextMatchID`.\r\n   *\r\n   * @example\r\n   * lobbyClient.playAgain('tic-tac-toe', 'xyz', {\r\n   *   playerID: '0',\r\n   *   credentials: 'credentials-returned-when-joining',\r\n   * })\r\n   *   .then(({ nextMatchID }) => {\r\n   *     return lobbyClient.joinMatch('tic-tac-toe', nextMatchID, {\r\n   *       playerID: '0',\r\n   *       playerName: 'Al',\r\n   *     })\r\n   *   })\r\n   *   .then({ playerCredentials } => {\r\n   *     console.log(playerCredentials);\r\n   *   })\r\n   *   .catch(console.error);\r\n   */\n\n\n  async playAgain(gameName, matchID, body, init) {\n    assertGameName(gameName);\n    assertMatchID(matchID);\n    validateBody(body, {\n      playerID: 'string',\n      credentials: 'string'\n    });\n    return this.post(`/games/${gameName}/${matchID}/playAgain`, {\n      body,\n      init\n    });\n  }\n\n}\n\nexport { LobbyClient as L, LobbyClientError as a };","map":{"version":3,"sources":["/Users/andywang/Desktop/CS161_Breadsticks/node_modules/boardgame.io/dist/esm/client-5f57c3f2.js"],"names":["assertString","str","label","Error","assertGameName","name","assertMatchID","id","validateBody","body","schema","key","propSchema","types","Array","isArray","received","includes","union","join","TypeError","LobbyClientError","constructor","message","details","LobbyClient","server","replace","request","route","init","response","fetch","ok","clone","json","text","error","status","post","opts","method","JSON","stringify","headers","listGames","listMatches","gameName","where","query","queries","isGameover","updatedBefore","updatedAfter","undefined","push","length","getMatch","matchID","createMatch","numPlayers","joinMatch","playerID","playerName","leaveMatch","credentials","updatePlayer","playAgain","L","a"],"mappings":"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","sourcesContent":["const assertString = (str, label) => {\r\n    if (!str || typeof str !== 'string') {\r\n        throw new Error(`Expected ${label} string, got \"${str}\".`);\r\n    }\r\n};\r\nconst assertGameName = (name) => assertString(name, 'game name');\r\nconst assertMatchID = (id) => assertString(id, 'match ID');\r\nconst validateBody = (body, schema) => {\r\n    if (!body)\r\n        throw new Error(`Expected body, got “${body}”.`);\r\n    for (const key in schema) {\r\n        const propSchema = schema[key];\r\n        const types = Array.isArray(propSchema) ? propSchema : [propSchema];\r\n        const received = body[key];\r\n        if (!types.includes(typeof received)) {\r\n            const union = types.join('|');\r\n            throw new TypeError(`Expected body.${key} to be of type ${union}, got “${received}”.`);\r\n        }\r\n    }\r\n};\r\nclass LobbyClientError extends Error {\r\n    constructor(message, details) {\r\n        super(message);\r\n        this.details = details;\r\n    }\r\n}\r\n/**\r\n * Create a boardgame.io Lobby API client.\r\n * @param server The API’s base URL, e.g. `http://localhost:8000`.\r\n */\r\nclass LobbyClient {\r\n    constructor({ server = '' } = {}) {\r\n        // strip trailing slash if passed\r\n        this.server = server.replace(/\\/$/, '');\r\n    }\r\n    async request(route, init) {\r\n        const response = await fetch(this.server + route, init);\r\n        if (!response.ok) {\r\n            let details;\r\n            try {\r\n                details = await response.clone().json();\r\n            }\r\n            catch {\r\n                try {\r\n                    details = await response.text();\r\n                }\r\n                catch (error) {\r\n                    details = error.message;\r\n                }\r\n            }\r\n            throw new LobbyClientError(`HTTP status ${response.status}`, details);\r\n        }\r\n        return response.json();\r\n    }\r\n    async post(route, opts) {\r\n        let init = {\r\n            method: 'post',\r\n            body: JSON.stringify(opts.body),\r\n            headers: { 'Content-Type': 'application/json' },\r\n        };\r\n        if (opts.init)\r\n            init = {\r\n                ...init,\r\n                ...opts.init,\r\n                headers: { ...init.headers, ...opts.init.headers },\r\n            };\r\n        return this.request(route, init);\r\n    }\r\n    /**\r\n     * Get a list of the game names available on this server.\r\n     * @param  init Optional RequestInit interface to override defaults.\r\n     * @return Array of game names.\r\n     *\r\n     * @example\r\n     * lobbyClient.listGames()\r\n     *   .then(console.log); // => ['chess', 'tic-tac-toe']\r\n     */\r\n    async listGames(init) {\r\n        return this.request('/games', init);\r\n    }\r\n    /**\r\n     * Get a list of the matches for a specific game type on the server.\r\n     * @param  gameName The game to list for, e.g. 'tic-tac-toe'.\r\n     * @param  where    Options to filter matches by update time or gameover state\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return Array of match metadata objects.\r\n     *\r\n     * @example\r\n     * lobbyClient.listMatches('tic-tac-toe', where: { isGameover: false })\r\n     *   .then(data => console.log(data.matches));\r\n     * // => [\r\n     * //   {\r\n     * //     matchID: 'xyz',\r\n     * //     gameName: 'tic-tac-toe',\r\n     * //     players: [{ id: 0, name: 'Alice' }, { id: 1 }]\r\n     * //   },\r\n     * //   ...\r\n     * // ]\r\n     */\r\n    async listMatches(gameName, where, init) {\r\n        assertGameName(gameName);\r\n        let query = '';\r\n        if (where) {\r\n            const queries = [];\r\n            const { isGameover, updatedBefore, updatedAfter } = where;\r\n            if (isGameover !== undefined)\r\n                queries.push(`isGameover=${isGameover}`);\r\n            if (updatedBefore)\r\n                queries.push(`updatedBefore=${updatedBefore}`);\r\n            if (updatedAfter)\r\n                queries.push(`updatedAfter=${updatedAfter}`);\r\n            if (queries.length > 0)\r\n                query = '?' + queries.join('&');\r\n        }\r\n        return this.request(`/games/${gameName}${query}`, init);\r\n    }\r\n    /**\r\n     * Get metadata for a specific match.\r\n     * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n     * @param  matchID  Match ID for the match to fetch.\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return A match metadata object.\r\n     *\r\n     * @example\r\n     * lobbyClient.getMatch('tic-tac-toe', 'xyz').then(console.log);\r\n     * // => {\r\n     * //   matchID: 'xyz',\r\n     * //   gameName: 'tic-tac-toe',\r\n     * //   players: [{ id: 0, name: 'Alice' }, { id: 1 }]\r\n     * // }\r\n     */\r\n    async getMatch(gameName, matchID, init) {\r\n        assertGameName(gameName);\r\n        assertMatchID(matchID);\r\n        return this.request(`/games/${gameName}/${matchID}`, init);\r\n    }\r\n    /**\r\n     * Create a new match for a specific game type.\r\n     * @param  gameName The game to create a match for, e.g. 'tic-tac-toe'.\r\n     * @param  body     Options required to configure match creation.\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return An object containing the created `matchID`.\r\n     *\r\n     * @example\r\n     * lobbyClient.createMatch('tic-tac-toe', { numPlayers: 2 })\r\n     *   .then(console.log);\r\n     * // => { matchID: 'xyz' }\r\n     */\r\n    async createMatch(gameName, body, init) {\r\n        assertGameName(gameName);\r\n        validateBody(body, { numPlayers: 'number' });\r\n        return this.post(`/games/${gameName}/create`, { body, init });\r\n    }\r\n    /**\r\n     * Join a match using its matchID.\r\n     * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n     * @param  matchID  Match ID for the match to join.\r\n     * @param  body     Options required to join match.\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return Object containing `playerCredentials` for the player who joined.\r\n     *\r\n     * @example\r\n     * lobbyClient.joinMatch('tic-tac-toe', 'xyz', {\r\n     *   playerID: '1',\r\n     *   playerName: 'Bob',\r\n     * }).then(console.log);\r\n     * // => { playerID: '1', playerCredentials: 'random-string' }\r\n     */\r\n    async joinMatch(gameName, matchID, body, init) {\r\n        assertGameName(gameName);\r\n        assertMatchID(matchID);\r\n        validateBody(body, {\r\n            playerID: ['string', 'undefined'],\r\n            playerName: 'string',\r\n        });\r\n        return this.post(`/games/${gameName}/${matchID}/join`, { body, init });\r\n    }\r\n    /**\r\n     * Leave a previously joined match.\r\n     * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n     * @param  matchID  Match ID for the match to leave.\r\n     * @param  body     Options required to leave match.\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return Promise resolves if successful.\r\n     *\r\n     * @example\r\n     * lobbyClient.leaveMatch('tic-tac-toe', 'xyz', {\r\n     *   playerID: '1',\r\n     *   credentials: 'credentials-returned-when-joining',\r\n     * })\r\n     *   .then(() => console.log('Left match.'))\r\n     *   .catch(error => console.error('Error leaving match', error));\r\n     */\r\n    async leaveMatch(gameName, matchID, body, init) {\r\n        assertGameName(gameName);\r\n        assertMatchID(matchID);\r\n        validateBody(body, { playerID: 'string', credentials: 'string' });\r\n        await this.post(`/games/${gameName}/${matchID}/leave`, { body, init });\r\n    }\r\n    /**\r\n     * Update a player’s name or custom metadata.\r\n     * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n     * @param  matchID  Match ID for the match to update.\r\n     * @param  body     Options required to update player.\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return Promise resolves if successful.\r\n     *\r\n     * @example\r\n     * lobbyClient.updatePlayer('tic-tac-toe', 'xyz', {\r\n     *   playerID: '0',\r\n     *   credentials: 'credentials-returned-when-joining',\r\n     *   newName: 'Al',\r\n     * })\r\n     *   .then(() => console.log('Updated player data.'))\r\n     *   .catch(error => console.error('Error updating data', error));\r\n     */\r\n    async updatePlayer(gameName, matchID, body, init) {\r\n        assertGameName(gameName);\r\n        assertMatchID(matchID);\r\n        validateBody(body, { playerID: 'string', credentials: 'string' });\r\n        await this.post(`/games/${gameName}/${matchID}/update`, { body, init });\r\n    }\r\n    /**\r\n     * Create a new match based on the configuration of the current match.\r\n     * @param  gameName The match’s game type, e.g. 'tic-tac-toe'.\r\n     * @param  matchID  Match ID for the match to play again.\r\n     * @param  body     Options required to configure match.\r\n     * @param  init     Optional RequestInit interface to override defaults.\r\n     * @return Object containing `nextMatchID`.\r\n     *\r\n     * @example\r\n     * lobbyClient.playAgain('tic-tac-toe', 'xyz', {\r\n     *   playerID: '0',\r\n     *   credentials: 'credentials-returned-when-joining',\r\n     * })\r\n     *   .then(({ nextMatchID }) => {\r\n     *     return lobbyClient.joinMatch('tic-tac-toe', nextMatchID, {\r\n     *       playerID: '0',\r\n     *       playerName: 'Al',\r\n     *     })\r\n     *   })\r\n     *   .then({ playerCredentials } => {\r\n     *     console.log(playerCredentials);\r\n     *   })\r\n     *   .catch(console.error);\r\n     */\r\n    async playAgain(gameName, matchID, body, init) {\r\n        assertGameName(gameName);\r\n        assertMatchID(matchID);\r\n        validateBody(body, { playerID: 'string', credentials: 'string' });\r\n        return this.post(`/games/${gameName}/${matchID}/playAgain`, { body, init });\r\n    }\r\n}\n\nexport { LobbyClient as L, LobbyClientError as a };\n"]},"metadata":{},"sourceType":"module"}