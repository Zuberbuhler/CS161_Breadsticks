{"ast":null,"code":"import { e as error, G as GameMethod, E as EnhanceCtx, T as TurnOrder, a as supportDeprecatedMoveLimit, S as Stage, b as SetActivePlayers, i as info, F as FnWrap, I as InitTurnOrderState, U as UpdateTurnOrderState, c as UpdateActivePlayersOnceEmpty, g as gameEvent, P as PATCH, d as PLUGIN, f as ProcessAction, R as REDO, h as UNDO, j as SYNC, k as UPDATE, l as RESET, M as MAKE_MOVE, m as Enhance, n as INVALID_MOVE, N as NoClient, o as GAME_EVENT, p as STRIP_TRANSIENTS, q as FlushAndValidate, r as stripTransients } from './turn-order-0b7dce3d.js';\nimport { applyPatch } from 'rfc6902';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Flow\r\n *\r\n * Creates a reducer that updates ctx (analogous to how moves update G).\r\n */\n\nfunction Flow(_ref) {\n  let {\n    moves,\n    phases,\n    endIf,\n    onEnd,\n    turn,\n    events,\n    plugins\n  } = _ref;\n\n  // Attach defaults.\n  if (moves === undefined) {\n    moves = {};\n  }\n\n  if (events === undefined) {\n    events = {};\n  }\n\n  if (plugins === undefined) {\n    plugins = [];\n  }\n\n  if (phases === undefined) {\n    phases = {};\n  }\n\n  if (!endIf) endIf = () => undefined;\n  if (!onEnd) onEnd = G => G;\n  if (!turn) turn = {};\n  const phaseMap = { ...phases\n  };\n\n  if ('' in phaseMap) {\n    error('cannot specify phase with empty name');\n  }\n\n  phaseMap[''] = {};\n  const moveMap = {};\n  const moveNames = new Set();\n  let startingPhase = null;\n  Object.keys(moves).forEach(name => moveNames.add(name));\n\n  const HookWrapper = (hook, hookType) => {\n    const withPlugins = FnWrap(hook, hookType, plugins);\n    return state => {\n      const ctxWithAPI = EnhanceCtx(state);\n      return withPlugins(state.G, ctxWithAPI);\n    };\n  };\n\n  const TriggerWrapper = trigger => {\n    return state => {\n      const ctxWithAPI = EnhanceCtx(state);\n      return trigger(state.G, ctxWithAPI);\n    };\n  };\n\n  const wrapped = {\n    onEnd: HookWrapper(onEnd, GameMethod.GAME_ON_END),\n    endIf: TriggerWrapper(endIf)\n  };\n\n  for (const phase in phaseMap) {\n    const phaseConfig = phaseMap[phase];\n\n    if (phaseConfig.start === true) {\n      startingPhase = phase;\n    }\n\n    if (phaseConfig.moves !== undefined) {\n      for (const move of Object.keys(phaseConfig.moves)) {\n        moveMap[phase + '.' + move] = phaseConfig.moves[move];\n        moveNames.add(move);\n      }\n    }\n\n    if (phaseConfig.endIf === undefined) {\n      phaseConfig.endIf = () => undefined;\n    }\n\n    if (phaseConfig.onBegin === undefined) {\n      phaseConfig.onBegin = G => G;\n    }\n\n    if (phaseConfig.onEnd === undefined) {\n      phaseConfig.onEnd = G => G;\n    }\n\n    if (phaseConfig.turn === undefined) {\n      phaseConfig.turn = turn;\n    }\n\n    if (phaseConfig.turn.order === undefined) {\n      phaseConfig.turn.order = TurnOrder.DEFAULT;\n    }\n\n    if (phaseConfig.turn.onBegin === undefined) {\n      phaseConfig.turn.onBegin = G => G;\n    }\n\n    if (phaseConfig.turn.onEnd === undefined) {\n      phaseConfig.turn.onEnd = G => G;\n    }\n\n    if (phaseConfig.turn.endIf === undefined) {\n      phaseConfig.turn.endIf = () => false;\n    }\n\n    if (phaseConfig.turn.onMove === undefined) {\n      phaseConfig.turn.onMove = G => G;\n    }\n\n    if (phaseConfig.turn.stages === undefined) {\n      phaseConfig.turn.stages = {};\n    } // turns previously treated moveLimit as both minMoves and maxMoves, this behaviour is kept intentionally\n\n\n    supportDeprecatedMoveLimit(phaseConfig.turn, true);\n\n    for (const stage in phaseConfig.turn.stages) {\n      const stageConfig = phaseConfig.turn.stages[stage];\n      const moves = stageConfig.moves || {};\n\n      for (const move of Object.keys(moves)) {\n        const key = phase + '.' + stage + '.' + move;\n        moveMap[key] = moves[move];\n        moveNames.add(move);\n      }\n    }\n\n    phaseConfig.wrapped = {\n      onBegin: HookWrapper(phaseConfig.onBegin, GameMethod.PHASE_ON_BEGIN),\n      onEnd: HookWrapper(phaseConfig.onEnd, GameMethod.PHASE_ON_END),\n      endIf: TriggerWrapper(phaseConfig.endIf)\n    };\n    phaseConfig.turn.wrapped = {\n      onMove: HookWrapper(phaseConfig.turn.onMove, GameMethod.TURN_ON_MOVE),\n      onBegin: HookWrapper(phaseConfig.turn.onBegin, GameMethod.TURN_ON_BEGIN),\n      onEnd: HookWrapper(phaseConfig.turn.onEnd, GameMethod.TURN_ON_END),\n      endIf: TriggerWrapper(phaseConfig.turn.endIf)\n    };\n\n    if (typeof phaseConfig.next !== 'function') {\n      const {\n        next\n      } = phaseConfig;\n\n      phaseConfig.next = () => next || null;\n    }\n\n    phaseConfig.wrapped.next = TriggerWrapper(phaseConfig.next);\n  }\n\n  function GetPhase(ctx) {\n    return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];\n  }\n\n  function OnMove(s) {\n    return s;\n  }\n\n  function Process(state, events) {\n    const phasesEnded = new Set();\n    const turnsEnded = new Set();\n\n    for (let i = 0; i < events.length; i++) {\n      const {\n        fn,\n        arg,\n        ...rest\n      } = events[i]; // Detect a loop of EndPhase calls.\n      // This could potentially even be an infinite loop\n      // if the endIf condition of each phase blindly\n      // returns true. The moment we detect a single\n      // loop, we just bail out of all phases.\n\n      if (fn === EndPhase) {\n        turnsEnded.clear();\n        const phase = state.ctx.phase;\n\n        if (phasesEnded.has(phase)) {\n          const ctx = { ...state.ctx,\n            phase: null\n          };\n          return { ...state,\n            ctx\n          };\n        }\n\n        phasesEnded.add(phase);\n      } // Process event.\n\n\n      const next = [];\n      state = fn(state, { ...rest,\n        arg,\n        next\n      });\n\n      if (fn === EndGame) {\n        break;\n      } // Check if we should end the game.\n\n\n      const shouldEndGame = ShouldEndGame(state);\n\n      if (shouldEndGame) {\n        events.push({\n          fn: EndGame,\n          arg: shouldEndGame,\n          turn: state.ctx.turn,\n          phase: state.ctx.phase,\n          automatic: true\n        });\n        continue;\n      } // Check if we should end the phase.\n\n\n      const shouldEndPhase = ShouldEndPhase(state);\n\n      if (shouldEndPhase) {\n        events.push({\n          fn: EndPhase,\n          arg: shouldEndPhase,\n          turn: state.ctx.turn,\n          phase: state.ctx.phase,\n          automatic: true\n        });\n        continue;\n      } // Check if we should end the turn.\n\n\n      if ([OnMove, UpdateStage, UpdateActivePlayers].includes(fn)) {\n        const shouldEndTurn = ShouldEndTurn(state);\n\n        if (shouldEndTurn) {\n          events.push({\n            fn: EndTurn,\n            arg: shouldEndTurn,\n            turn: state.ctx.turn,\n            phase: state.ctx.phase,\n            automatic: true\n          });\n          continue;\n        }\n      }\n\n      events.push(...next);\n    }\n\n    return state;\n  } ///////////\n  // Start //\n  ///////////\n\n\n  function StartGame(state, _ref2) {\n    let {\n      next\n    } = _ref2;\n    next.push({\n      fn: StartPhase\n    });\n    return state;\n  }\n\n  function StartPhase(state, _ref3) {\n    let {\n      next\n    } = _ref3;\n    let {\n      G,\n      ctx\n    } = state;\n    const phaseConfig = GetPhase(ctx); // Run any phase setup code provided by the user.\n\n    G = phaseConfig.wrapped.onBegin(state);\n    next.push({\n      fn: StartTurn\n    });\n    return { ...state,\n      G,\n      ctx\n    };\n  }\n\n  function StartTurn(state, _ref4) {\n    let {\n      currentPlayer\n    } = _ref4;\n    let {\n      ctx\n    } = state;\n    const phaseConfig = GetPhase(ctx); // Initialize the turn order state.\n\n    if (currentPlayer) {\n      ctx = { ...ctx,\n        currentPlayer\n      };\n\n      if (phaseConfig.turn.activePlayers) {\n        ctx = SetActivePlayers(ctx, phaseConfig.turn.activePlayers);\n      }\n    } else {\n      // This is only called at the beginning of the phase\n      // when there is no currentPlayer yet.\n      ctx = InitTurnOrderState(state, phaseConfig.turn);\n    }\n\n    const turn = ctx.turn + 1;\n    ctx = { ...ctx,\n      turn,\n      numMoves: 0,\n      _prevActivePlayers: []\n    };\n    const G = phaseConfig.turn.wrapped.onBegin({ ...state,\n      ctx\n    });\n    return { ...state,\n      G,\n      ctx,\n      _undo: [],\n      _redo: []\n    };\n  } ////////////\n  // Update //\n  ////////////\n\n\n  function UpdatePhase(state, _ref5) {\n    let {\n      arg,\n      next,\n      phase\n    } = _ref5;\n    const phaseConfig = GetPhase({\n      phase\n    });\n    let {\n      ctx\n    } = state;\n\n    if (arg && arg.next) {\n      if (arg.next in phaseMap) {\n        ctx = { ...ctx,\n          phase: arg.next\n        };\n      } else {\n        error('invalid phase: ' + arg.next);\n        return state;\n      }\n    } else {\n      ctx = { ...ctx,\n        phase: phaseConfig.wrapped.next(state) || null\n      };\n    }\n\n    state = { ...state,\n      ctx\n    }; // Start the new phase.\n\n    next.push({\n      fn: StartPhase\n    });\n    return state;\n  }\n\n  function UpdateTurn(state, _ref6) {\n    let {\n      arg,\n      currentPlayer,\n      next\n    } = _ref6;\n    let {\n      G,\n      ctx\n    } = state;\n    const phaseConfig = GetPhase(ctx); // Update turn order state.\n\n    const {\n      endPhase,\n      ctx: newCtx\n    } = UpdateTurnOrderState(state, currentPlayer, phaseConfig.turn, arg);\n    ctx = newCtx;\n    state = { ...state,\n      G,\n      ctx\n    };\n\n    if (endPhase) {\n      next.push({\n        fn: EndPhase,\n        turn: ctx.turn,\n        phase: ctx.phase\n      });\n    } else {\n      next.push({\n        fn: StartTurn,\n        currentPlayer: ctx.currentPlayer\n      });\n    }\n\n    return state;\n  }\n\n  function UpdateStage(state, _ref7) {\n    let {\n      arg,\n      playerID\n    } = _ref7;\n\n    if (typeof arg === 'string' || arg === Stage.NULL) {\n      arg = {\n        stage: arg\n      };\n    }\n\n    if (typeof arg !== 'object') return state; // `arg` should be of type `StageArg`, loose typing as `any` here for historic reasons\n    // stages previously did not enforce minMoves, this behaviour is kept intentionally\n\n    supportDeprecatedMoveLimit(arg);\n    let {\n      ctx\n    } = state;\n    let {\n      activePlayers,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves,\n      _activePlayersNumMoves\n    } = ctx; // Checking if stage is valid, even Stage.NULL\n\n    if (arg.stage !== undefined) {\n      if (activePlayers === null) {\n        activePlayers = {};\n      }\n\n      activePlayers[playerID] = arg.stage;\n      _activePlayersNumMoves[playerID] = 0;\n\n      if (arg.minMoves) {\n        if (_activePlayersMinMoves === null) {\n          _activePlayersMinMoves = {};\n        }\n\n        _activePlayersMinMoves[playerID] = arg.minMoves;\n      }\n\n      if (arg.maxMoves) {\n        if (_activePlayersMaxMoves === null) {\n          _activePlayersMaxMoves = {};\n        }\n\n        _activePlayersMaxMoves[playerID] = arg.maxMoves;\n      }\n    }\n\n    ctx = { ...ctx,\n      activePlayers,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves,\n      _activePlayersNumMoves\n    };\n    return { ...state,\n      ctx\n    };\n  }\n\n  function UpdateActivePlayers(state, _ref8) {\n    let {\n      arg\n    } = _ref8;\n    return { ...state,\n      ctx: SetActivePlayers(state.ctx, arg)\n    };\n  } ///////////////\n  // ShouldEnd //\n  ///////////////\n\n\n  function ShouldEndGame(state) {\n    return wrapped.endIf(state);\n  }\n\n  function ShouldEndPhase(state) {\n    const phaseConfig = GetPhase(state.ctx);\n    return phaseConfig.wrapped.endIf(state);\n  }\n\n  function ShouldEndTurn(state) {\n    const phaseConfig = GetPhase(state.ctx); // End the turn if the required number of moves has been made.\n\n    const currentPlayerMoves = state.ctx.numMoves || 0;\n\n    if (phaseConfig.turn.maxMoves && currentPlayerMoves >= phaseConfig.turn.maxMoves) {\n      return true;\n    }\n\n    return phaseConfig.turn.wrapped.endIf(state);\n  } /////////\n  // End //\n  /////////\n\n\n  function EndGame(state, _ref9) {\n    let {\n      arg,\n      phase\n    } = _ref9;\n    state = EndPhase(state, {\n      phase\n    });\n\n    if (arg === undefined) {\n      arg = true;\n    }\n\n    state = { ...state,\n      ctx: { ...state.ctx,\n        gameover: arg\n      }\n    }; // Run game end hook.\n\n    const G = wrapped.onEnd(state);\n    return { ...state,\n      G\n    };\n  }\n\n  function EndPhase(state, _ref10) {\n    let {\n      arg,\n      next,\n      turn: initialTurn,\n      automatic\n    } = _ref10;\n    // End the turn first.\n    state = EndTurn(state, {\n      turn: initialTurn,\n      force: true,\n      automatic: true\n    });\n    const {\n      phase,\n      turn\n    } = state.ctx;\n\n    if (next) {\n      next.push({\n        fn: UpdatePhase,\n        arg,\n        phase\n      });\n    } // If we aren't in a phase, there is nothing else to do.\n\n\n    if (phase === null) {\n      return state;\n    } // Run any cleanup code for the phase that is about to end.\n\n\n    const phaseConfig = GetPhase(state.ctx);\n    const G = phaseConfig.wrapped.onEnd(state); // Reset the phase.\n\n    const ctx = { ...state.ctx,\n      phase: null\n    }; // Add log entry.\n\n    const action = gameEvent('endPhase', arg);\n    const {\n      _stateID\n    } = state;\n    const logEntry = {\n      action,\n      _stateID,\n      turn,\n      phase\n    };\n    if (automatic) logEntry.automatic = true;\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return { ...state,\n      G,\n      ctx,\n      deltalog\n    };\n  }\n\n  function EndTurn(state, _ref11) {\n    let {\n      arg,\n      next,\n      turn: initialTurn,\n      force,\n      automatic,\n      playerID\n    } = _ref11;\n\n    // This is not the turn that EndTurn was originally\n    // called for. The turn was probably ended some other way.\n    if (initialTurn !== state.ctx.turn) {\n      return state;\n    }\n\n    const {\n      currentPlayer,\n      numMoves,\n      phase,\n      turn\n    } = state.ctx;\n    const phaseConfig = GetPhase(state.ctx); // Prevent ending the turn if minMoves haven't been reached.\n\n    const currentPlayerMoves = numMoves || 0;\n\n    if (!force && phaseConfig.turn.minMoves && currentPlayerMoves < phaseConfig.turn.minMoves) {\n      info(`cannot end turn before making ${phaseConfig.turn.minMoves} moves`);\n      return state;\n    } // Run turn-end triggers.\n\n\n    const G = phaseConfig.turn.wrapped.onEnd(state);\n\n    if (next) {\n      next.push({\n        fn: UpdateTurn,\n        arg,\n        currentPlayer\n      });\n    } // Reset activePlayers.\n\n\n    let ctx = { ...state.ctx,\n      activePlayers: null\n    }; // Remove player from playerOrder\n\n    if (arg && arg.remove) {\n      playerID = playerID || currentPlayer;\n      const playOrder = ctx.playOrder.filter(i => i != playerID);\n      const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;\n      ctx = { ...ctx,\n        playOrder,\n        playOrderPos\n      };\n\n      if (playOrder.length === 0) {\n        next.push({\n          fn: EndPhase,\n          turn,\n          phase\n        });\n        return state;\n      }\n    } // Create log entry.\n\n\n    const action = gameEvent('endTurn', arg);\n    const {\n      _stateID\n    } = state;\n    const logEntry = {\n      action,\n      _stateID,\n      turn,\n      phase\n    };\n    if (automatic) logEntry.automatic = true;\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return { ...state,\n      G,\n      ctx,\n      deltalog,\n      _undo: [],\n      _redo: []\n    };\n  }\n\n  function EndStage(state, _ref12) {\n    let {\n      arg,\n      next,\n      automatic,\n      playerID\n    } = _ref12;\n    playerID = playerID || state.ctx.currentPlayer;\n    let {\n      ctx,\n      _stateID\n    } = state;\n    let {\n      activePlayers,\n      _activePlayersNumMoves,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves,\n      phase,\n      turn\n    } = ctx;\n    const playerInStage = activePlayers !== null && playerID in activePlayers;\n    const phaseConfig = GetPhase(ctx);\n\n    if (!arg && playerInStage) {\n      const stage = phaseConfig.turn.stages[activePlayers[playerID]];\n\n      if (stage && stage.next) {\n        arg = stage.next;\n      }\n    } // Checking if arg is a valid stage, even Stage.NULL\n\n\n    if (next) {\n      next.push({\n        fn: UpdateStage,\n        arg,\n        playerID\n      });\n    } // If player isn’t in a stage, there is nothing else to do.\n\n\n    if (!playerInStage) return state; // Prevent ending the stage if minMoves haven't been reached.\n\n    const currentPlayerMoves = _activePlayersNumMoves[playerID] || 0;\n\n    if (_activePlayersMinMoves && _activePlayersMinMoves[playerID] && currentPlayerMoves < _activePlayersMinMoves[playerID]) {\n      info(`cannot end stage before making ${_activePlayersMinMoves[playerID]} moves`);\n      return state;\n    } // Remove player from activePlayers.\n\n\n    activePlayers = { ...activePlayers\n    };\n    delete activePlayers[playerID];\n\n    if (_activePlayersMinMoves) {\n      // Remove player from _activePlayersMinMoves.\n      _activePlayersMinMoves = { ..._activePlayersMinMoves\n      };\n      delete _activePlayersMinMoves[playerID];\n    }\n\n    if (_activePlayersMaxMoves) {\n      // Remove player from _activePlayersMaxMoves.\n      _activePlayersMaxMoves = { ..._activePlayersMaxMoves\n      };\n      delete _activePlayersMaxMoves[playerID];\n    }\n\n    ctx = UpdateActivePlayersOnceEmpty({ ...ctx,\n      activePlayers,\n      _activePlayersMinMoves,\n      _activePlayersMaxMoves\n    }); // Create log entry.\n\n    const action = gameEvent('endStage', arg);\n    const logEntry = {\n      action,\n      _stateID,\n      turn,\n      phase\n    };\n    if (automatic) logEntry.automatic = true;\n    const deltalog = [...(state.deltalog || []), logEntry];\n    return { ...state,\n      ctx,\n      deltalog\n    };\n  }\n  /**\r\n   * Retrieves the relevant move that can be played by playerID.\r\n   *\r\n   * If ctx.activePlayers is set (i.e. one or more players are in some stage),\r\n   * then it attempts to find the move inside the stages config for\r\n   * that turn. If the stage for a player is '', then the player is\r\n   * allowed to make a move (as determined by the phase config), but\r\n   * isn't restricted to a particular set as defined in the stage config.\r\n   *\r\n   * If not, it then looks for the move inside the phase.\r\n   *\r\n   * If it doesn't find the move there, it looks at the global move definition.\r\n   *\r\n   * @param {object} ctx\r\n   * @param {string} name\r\n   * @param {string} playerID\r\n   */\n\n\n  function GetMove(ctx, name, playerID) {\n    const phaseConfig = GetPhase(ctx);\n    const stages = phaseConfig.turn.stages;\n    const {\n      activePlayers\n    } = ctx;\n\n    if (activePlayers && activePlayers[playerID] !== undefined && activePlayers[playerID] !== Stage.NULL && stages[activePlayers[playerID]] !== undefined && stages[activePlayers[playerID]].moves !== undefined) {\n      // Check if moves are defined for the player's stage.\n      const stage = stages[activePlayers[playerID]];\n      const moves = stage.moves;\n\n      if (name in moves) {\n        return moves[name];\n      }\n    } else if (phaseConfig.moves) {\n      // Check if moves are defined for the current phase.\n      if (name in phaseConfig.moves) {\n        return phaseConfig.moves[name];\n      }\n    } else if (name in moves) {\n      // Check for the move globally.\n      return moves[name];\n    }\n\n    return null;\n  }\n\n  function ProcessMove(state, action) {\n    const {\n      playerID,\n      type\n    } = action;\n    const {\n      currentPlayer,\n      activePlayers,\n      _activePlayersMaxMoves\n    } = state.ctx;\n    const move = GetMove(state.ctx, type, playerID);\n    const shouldCount = !move || typeof move === 'function' || move.noLimit !== true;\n    let {\n      numMoves,\n      _activePlayersNumMoves\n    } = state.ctx;\n\n    if (shouldCount) {\n      if (playerID === currentPlayer) numMoves++;\n      if (activePlayers) _activePlayersNumMoves[playerID]++;\n    }\n\n    state = { ...state,\n      ctx: { ...state.ctx,\n        numMoves,\n        _activePlayersNumMoves\n      }\n    };\n\n    if (_activePlayersMaxMoves && _activePlayersNumMoves[playerID] >= _activePlayersMaxMoves[playerID]) {\n      state = EndStage(state, {\n        playerID,\n        automatic: true\n      });\n    }\n\n    const phaseConfig = GetPhase(state.ctx);\n    const G = phaseConfig.turn.wrapped.onMove({ ...state,\n      ctx: { ...state.ctx,\n        playerID\n      }\n    });\n    state = { ...state,\n      G\n    };\n    const events = [{\n      fn: OnMove\n    }];\n    return Process(state, events);\n  }\n\n  function SetStageEvent(state, playerID, arg) {\n    return Process(state, [{\n      fn: EndStage,\n      arg,\n      playerID\n    }]);\n  }\n\n  function EndStageEvent(state, playerID) {\n    return Process(state, [{\n      fn: EndStage,\n      playerID\n    }]);\n  }\n\n  function SetActivePlayersEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: UpdateActivePlayers,\n      arg\n    }]);\n  }\n\n  function SetPhaseEvent(state, _playerID, newPhase) {\n    return Process(state, [{\n      fn: EndPhase,\n      phase: state.ctx.phase,\n      turn: state.ctx.turn,\n      arg: {\n        next: newPhase\n      }\n    }]);\n  }\n\n  function EndPhaseEvent(state) {\n    return Process(state, [{\n      fn: EndPhase,\n      phase: state.ctx.phase,\n      turn: state.ctx.turn\n    }]);\n  }\n\n  function EndTurnEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndTurn,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      arg\n    }]);\n  }\n\n  function PassEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndTurn,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      force: true,\n      arg\n    }]);\n  }\n\n  function EndGameEvent(state, _playerID, arg) {\n    return Process(state, [{\n      fn: EndGame,\n      turn: state.ctx.turn,\n      phase: state.ctx.phase,\n      arg\n    }]);\n  }\n\n  const eventHandlers = {\n    endStage: EndStageEvent,\n    setStage: SetStageEvent,\n    endTurn: EndTurnEvent,\n    pass: PassEvent,\n    endPhase: EndPhaseEvent,\n    setPhase: SetPhaseEvent,\n    endGame: EndGameEvent,\n    setActivePlayers: SetActivePlayersEvent\n  };\n  const enabledEventNames = [];\n\n  if (events.endTurn !== false) {\n    enabledEventNames.push('endTurn');\n  }\n\n  if (events.pass !== false) {\n    enabledEventNames.push('pass');\n  }\n\n  if (events.endPhase !== false) {\n    enabledEventNames.push('endPhase');\n  }\n\n  if (events.setPhase !== false) {\n    enabledEventNames.push('setPhase');\n  }\n\n  if (events.endGame !== false) {\n    enabledEventNames.push('endGame');\n  }\n\n  if (events.setActivePlayers !== false) {\n    enabledEventNames.push('setActivePlayers');\n  }\n\n  if (events.endStage !== false) {\n    enabledEventNames.push('endStage');\n  }\n\n  if (events.setStage !== false) {\n    enabledEventNames.push('setStage');\n  }\n\n  function ProcessEvent(state, action) {\n    const {\n      type,\n      playerID,\n      args\n    } = action.payload;\n    if (typeof eventHandlers[type] !== 'function') return state;\n    return eventHandlers[type](state, playerID, ...(Array.isArray(args) ? args : [args]));\n  }\n\n  function IsPlayerActive(_G, ctx, playerID) {\n    if (ctx.activePlayers) {\n      return playerID in ctx.activePlayers;\n    }\n\n    return ctx.currentPlayer === playerID;\n  }\n\n  return {\n    ctx: numPlayers => ({\n      numPlayers,\n      turn: 0,\n      currentPlayer: '0',\n      playOrder: [...Array.from({\n        length: numPlayers\n      })].map((_, i) => i + ''),\n      playOrderPos: 0,\n      phase: startingPhase,\n      activePlayers: null\n    }),\n    init: state => {\n      return Process(state, [{\n        fn: StartGame\n      }]);\n    },\n    isPlayerActive: IsPlayerActive,\n    eventHandlers,\n    eventNames: Object.keys(eventHandlers),\n    enabledEventNames,\n    moveMap,\n    moveNames: [...moveNames.values()],\n    processMove: ProcessMove,\n    processEvent: ProcessEvent,\n    getMove: GetMove\n  };\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nfunction IsProcessed(game) {\n  return game.processMove !== undefined;\n}\n/**\r\n * Helper to generate the game move reducer. The returned\r\n * reducer has the following signature:\r\n *\r\n * (G, action, ctx) => {}\r\n *\r\n * You can roll your own if you like, or use any Redux\r\n * addon to generate such a reducer.\r\n *\r\n * The convention used in this framework is to\r\n * have action.type contain the name of the move, and\r\n * action.args contain any additional arguments as an\r\n * Array.\r\n */\n\n\nfunction ProcessGameConfig(game) {\n  // The Game() function has already been called on this\n  // config object, so just pass it through.\n  if (IsProcessed(game)) {\n    return game;\n  }\n\n  if (game.name === undefined) game.name = 'default';\n  if (game.deltaState === undefined) game.deltaState = false;\n  if (game.disableUndo === undefined) game.disableUndo = false;\n  if (game.setup === undefined) game.setup = () => ({});\n  if (game.moves === undefined) game.moves = {};\n  if (game.playerView === undefined) game.playerView = G => G;\n  if (game.plugins === undefined) game.plugins = [];\n  game.plugins.forEach(plugin => {\n    if (plugin.name === undefined) {\n      throw new Error('Plugin missing name attribute');\n    }\n\n    if (plugin.name.includes(' ')) {\n      throw new Error(plugin.name + ': Plugin name must not include spaces');\n    }\n  });\n\n  if (game.name.includes(' ')) {\n    throw new Error(game.name + ': Game name must not include spaces');\n  }\n\n  const flow = Flow(game);\n  return { ...game,\n    flow,\n    moveNames: flow.moveNames,\n    pluginNames: game.plugins.map(p => p.name),\n    processMove: (state, action) => {\n      let moveFn = flow.getMove(state.ctx, action.type, action.playerID);\n\n      if (IsLongFormMove(moveFn)) {\n        moveFn = moveFn.move;\n      }\n\n      if (moveFn instanceof Function) {\n        const fn = FnWrap(moveFn, GameMethod.MOVE, game.plugins);\n        const ctxWithAPI = { ...EnhanceCtx(state),\n          playerID: action.playerID\n        };\n        let args = [];\n\n        if (action.args !== undefined) {\n          args = Array.isArray(action.args) ? action.args : [action.args];\n        }\n\n        return fn(state.G, ctxWithAPI, ...args);\n      }\n\n      error(`invalid move object: ${action.type}`);\n      return state.G;\n    }\n  };\n}\n\nfunction IsLongFormMove(move) {\n  return move instanceof Object && move.move !== undefined;\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nvar UpdateErrorType;\n\n(function (UpdateErrorType) {\n  // The action’s credentials were missing or invalid\n  UpdateErrorType[\"UnauthorizedAction\"] = \"update/unauthorized_action\"; // The action’s matchID was not found\n\n  UpdateErrorType[\"MatchNotFound\"] = \"update/match_not_found\"; // Could not apply Patch operation (rfc6902).\n\n  UpdateErrorType[\"PatchFailed\"] = \"update/patch_failed\";\n})(UpdateErrorType || (UpdateErrorType = {}));\n\nvar ActionErrorType;\n\n(function (ActionErrorType) {\n  // The action contained a stale state ID\n  ActionErrorType[\"StaleStateId\"] = \"action/stale_state_id\"; // The requested move is unknown or not currently available\n\n  ActionErrorType[\"UnavailableMove\"] = \"action/unavailable_move\"; // The move declared it was invalid (INVALID_MOVE constant)\n\n  ActionErrorType[\"InvalidMove\"] = \"action/invalid_move\"; // The player making the action is not currently active\n\n  ActionErrorType[\"InactivePlayer\"] = \"action/inactive_player\"; // The game has finished\n\n  ActionErrorType[\"GameOver\"] = \"action/gameover\"; // The requested action is disabled (e.g. undo/redo, events)\n\n  ActionErrorType[\"ActionDisabled\"] = \"action/action_disabled\"; // The requested action is not currently possible\n\n  ActionErrorType[\"ActionInvalid\"] = \"action/action_invalid\"; // The requested action was declared invalid by a plugin\n\n  ActionErrorType[\"PluginActionInvalid\"] = \"action/plugin_invalid\";\n})(ActionErrorType || (ActionErrorType = {}));\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Check if the payload for the passed action contains a playerID.\r\n */\n\n\nconst actionHasPlayerID = action => action.payload.playerID !== null && action.payload.playerID !== undefined;\n/**\r\n * Returns true if a move can be undone.\r\n */\n\n\nconst CanUndoMove = (G, ctx, move) => {\n  function HasUndoable(move) {\n    return move.undoable !== undefined;\n  }\n\n  function IsFunction(undoable) {\n    return undoable instanceof Function;\n  }\n\n  if (!HasUndoable(move)) {\n    return true;\n  }\n\n  if (IsFunction(move.undoable)) {\n    return move.undoable(G, ctx);\n  }\n\n  return move.undoable;\n};\n/**\r\n * Update the undo and redo stacks for a move or event.\r\n */\n\n\nfunction updateUndoRedoState(state, opts) {\n  if (opts.game.disableUndo) return state;\n  const undoEntry = {\n    G: state.G,\n    ctx: state.ctx,\n    plugins: state.plugins,\n    playerID: opts.action.payload.playerID || state.ctx.currentPlayer\n  };\n\n  if (opts.action.type === 'MAKE_MOVE') {\n    undoEntry.moveType = opts.action.payload.type;\n  }\n\n  return { ...state,\n    _undo: [...state._undo, undoEntry],\n    // Always reset redo stack when making a move or event\n    _redo: []\n  };\n}\n/**\r\n * Process state, adding the initial deltalog for this action.\r\n */\n\n\nfunction initializeDeltalog(state, action, move) {\n  // Create a log entry for this action.\n  const logEntry = {\n    action,\n    _stateID: state._stateID,\n    turn: state.ctx.turn,\n    phase: state.ctx.phase\n  };\n  const pluginLogMetadata = state.plugins.log.data.metadata;\n\n  if (pluginLogMetadata !== undefined) {\n    logEntry.metadata = pluginLogMetadata;\n  }\n\n  if (typeof move === 'object' && move.redact === true) {\n    logEntry.redact = true;\n  }\n\n  return { ...state,\n    deltalog: [logEntry]\n  };\n}\n/**\r\n * Update plugin state after move/event & check if plugins consider the action to be valid.\r\n * @param state Current version of state in the reducer.\r\n * @param oldState State to revert to in case of error.\r\n * @param pluginOpts Plugin configuration options.\r\n * @returns Tuple of the new state updated after flushing plugins and the old\r\n * state augmented with an error if a plugin declared the action invalid.\r\n */\n\n\nfunction flushAndValidatePlugins(state, oldState, pluginOpts) {\n  const [newState, isInvalid] = FlushAndValidate(state, pluginOpts);\n  if (!isInvalid) return [newState];\n  return [newState, WithError(oldState, ActionErrorType.PluginActionInvalid, isInvalid)];\n}\n/**\r\n * ExtractTransientsFromState\r\n *\r\n * Split out transients from the a TransientState\r\n */\n\n\nfunction ExtractTransients(transientState) {\n  if (!transientState) {\n    // We preserve null for the state for legacy callers, but the transient\n    // field should be undefined if not present to be consistent with the\n    // code path below.\n    return [null, undefined];\n  }\n\n  const {\n    transients,\n    ...state\n  } = transientState;\n  return [state, transients];\n}\n/**\r\n * WithError\r\n *\r\n * Augment a State instance with transient error information.\r\n */\n\n\nfunction WithError(state, errorType, payload) {\n  const error = {\n    type: errorType,\n    payload\n  };\n  return { ...state,\n    transients: {\n      error\n    }\n  };\n}\n/**\r\n * Middleware for processing TransientState associated with the reducer\r\n * returned by CreateGameReducer.\r\n * This should pretty much be used everywhere you want realistic state\r\n * transitions and error handling.\r\n */\n\n\nconst TransientHandlingMiddleware = store => next => action => {\n  const result = next(action);\n\n  switch (action.type) {\n    case STRIP_TRANSIENTS:\n      {\n        return result;\n      }\n\n    default:\n      {\n        const [, transients] = ExtractTransients(store.getState());\n\n        if (typeof transients !== 'undefined') {\n          store.dispatch(stripTransients()); // Dev Note: If parent middleware needs to correlate the spawned\n          // StripTransients action to the triggering action, instrument here.\n          //\n          // This is a bit tricky; for more details, see:\n          //   https://github.com/boardgameio/boardgame.io/pull/940#discussion_r636200648\n\n          return { ...result,\n            transients\n          };\n        }\n\n        return result;\n      }\n  }\n};\n/**\r\n * CreateGameReducer\r\n *\r\n * Creates the main game state reducer.\r\n */\n\n\nfunction CreateGameReducer(_ref13) {\n  let {\n    game,\n    isClient\n  } = _ref13;\n  game = ProcessGameConfig(game);\n  /**\r\n   * GameReducer\r\n   *\r\n   * Redux reducer that maintains the overall game state.\r\n   * @param {object} state - The state before the action.\r\n   * @param {object} action - A Redux action.\r\n   */\n\n  return function () {\n    let stateWithTransients = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let action = arguments.length > 1 ? arguments[1] : undefined;\n    let [state\n    /*, transients */\n    ] = ExtractTransients(stateWithTransients);\n\n    switch (action.type) {\n      case STRIP_TRANSIENTS:\n        {\n          // This action indicates that transient metadata in the state has been\n          // consumed and should now be stripped from the state..\n          return state;\n        }\n\n      case GAME_EVENT:\n        {\n          state = { ...state,\n            deltalog: []\n          }; // Process game events only on the server.\n          // These events like `endTurn` typically\n          // contain code that may rely on secret state\n          // and cannot be computed on the client.\n\n          if (isClient) {\n            return state;\n          } // Disallow events once the game is over.\n\n\n          if (state.ctx.gameover !== undefined) {\n            error(`cannot call event after game end`);\n            return WithError(state, ActionErrorType.GameOver);\n          } // Ignore the event if the player isn't active.\n\n\n          if (actionHasPlayerID(action) && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\n            error(`disallowed event: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.InactivePlayer);\n          } // Execute plugins.\n\n\n          state = Enhance(state, {\n            game,\n            isClient: false,\n            playerID: action.payload.playerID\n          }); // Process event.\n\n          let newState = game.flow.processEvent(state, action); // Execute plugins.\n\n          let stateWithError;\n          [newState, stateWithError] = flushAndValidatePlugins(newState, state, {\n            game,\n            isClient: false\n          });\n          if (stateWithError) return stateWithError; // Update undo / redo state.\n\n          newState = updateUndoRedoState(newState, {\n            game,\n            action\n          });\n          return { ...newState,\n            _stateID: state._stateID + 1\n          };\n        }\n\n      case MAKE_MOVE:\n        {\n          const oldState = state = { ...state,\n            deltalog: []\n          }; // Check whether the move is allowed at this time.\n\n          const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);\n\n          if (move === null) {\n            error(`disallowed move: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.UnavailableMove);\n          } // Don't run move on client if move says so.\n\n\n          if (isClient && move.client === false) {\n            return state;\n          } // Disallow moves once the game is over.\n\n\n          if (state.ctx.gameover !== undefined) {\n            error(`cannot make move after game end`);\n            return WithError(state, ActionErrorType.GameOver);\n          } // Ignore the move if the player isn't active.\n\n\n          if (actionHasPlayerID(action) && !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\n            error(`disallowed move: ${action.payload.type}`);\n            return WithError(state, ActionErrorType.InactivePlayer);\n          } // Execute plugins.\n\n\n          state = Enhance(state, {\n            game,\n            isClient,\n            playerID: action.payload.playerID\n          }); // Process the move.\n\n          const G = game.processMove(state, action.payload); // The game declared the move as invalid.\n\n          if (G === INVALID_MOVE) {\n            error(`invalid move: ${action.payload.type} args: ${action.payload.args}`); // TODO(#723): Marshal a nice error payload with the processed move.\n\n            return WithError(state, ActionErrorType.InvalidMove);\n          }\n\n          const newState = { ...state,\n            G\n          }; // Some plugin indicated that it is not suitable to be\n          // materialized on the client (and must wait for the server\n          // response instead).\n\n          if (isClient && NoClient(newState, {\n            game\n          })) {\n            return state;\n          }\n\n          state = newState; // If we're on the client, just process the move\n          // and no triggers in multiplayer mode.\n          // These will be processed on the server, which\n          // will send back a state update.\n\n          if (isClient) {\n            let stateWithError;\n            [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\n              game,\n              isClient: true\n            });\n            if (stateWithError) return stateWithError;\n            return { ...state,\n              _stateID: state._stateID + 1\n            };\n          } // On the server, construct the deltalog.\n\n\n          state = initializeDeltalog(state, action, move); // Allow the flow reducer to process any triggers that happen after moves.\n\n          state = game.flow.processMove(state, action.payload);\n          let stateWithError;\n          [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\n            game\n          });\n          if (stateWithError) return stateWithError; // Update undo / redo state.\n\n          state = updateUndoRedoState(state, {\n            game,\n            action\n          });\n          return { ...state,\n            _stateID: state._stateID + 1\n          };\n        }\n\n      case RESET:\n      case UPDATE:\n      case SYNC:\n        {\n          return action.state;\n        }\n\n      case UNDO:\n        {\n          state = { ...state,\n            deltalog: []\n          };\n\n          if (game.disableUndo) {\n            error('Undo is not enabled');\n            return WithError(state, ActionErrorType.ActionDisabled);\n          }\n\n          const {\n            G,\n            ctx,\n            _undo,\n            _redo,\n            _stateID\n          } = state;\n\n          if (_undo.length < 2) {\n            error(`No moves to undo`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n\n          const last = _undo[_undo.length - 1];\n          const restore = _undo[_undo.length - 2]; // Only allow players to undo their own moves.\n\n          if (actionHasPlayerID(action) && action.payload.playerID !== last.playerID) {\n            error(`Cannot undo other players' moves`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          } // If undoing a move, check it is undoable.\n\n\n          if (last.moveType) {\n            const lastMove = game.flow.getMove(restore.ctx, last.moveType, last.playerID);\n\n            if (!CanUndoMove(G, ctx, lastMove)) {\n              error(`Move cannot be undone`);\n              return WithError(state, ActionErrorType.ActionInvalid);\n            }\n          }\n\n          state = initializeDeltalog(state, action);\n          return { ...state,\n            G: restore.G,\n            ctx: restore.ctx,\n            plugins: restore.plugins,\n            _stateID: _stateID + 1,\n            _undo: _undo.slice(0, -1),\n            _redo: [last, ..._redo]\n          };\n        }\n\n      case REDO:\n        {\n          state = { ...state,\n            deltalog: []\n          };\n\n          if (game.disableUndo) {\n            error('Redo is not enabled');\n            return WithError(state, ActionErrorType.ActionDisabled);\n          }\n\n          const {\n            _undo,\n            _redo,\n            _stateID\n          } = state;\n\n          if (_redo.length === 0) {\n            error(`No moves to redo`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n\n          const first = _redo[0]; // Only allow players to redo their own undos.\n\n          if (actionHasPlayerID(action) && action.payload.playerID !== first.playerID) {\n            error(`Cannot redo other players' moves`);\n            return WithError(state, ActionErrorType.ActionInvalid);\n          }\n\n          state = initializeDeltalog(state, action);\n          return { ...state,\n            G: first.G,\n            ctx: first.ctx,\n            plugins: first.plugins,\n            _stateID: _stateID + 1,\n            _undo: [..._undo, first],\n            _redo: _redo.slice(1)\n          };\n        }\n\n      case PLUGIN:\n        {\n          // TODO(#723): Expose error semantics to plugin processing.\n          return ProcessAction(state, action, {\n            game\n          });\n        }\n\n      case PATCH:\n        {\n          const oldState = state;\n          const newState = JSON.parse(JSON.stringify(oldState));\n          const patchError = applyPatch(newState, action.patch);\n          const hasError = patchError.some(entry => entry !== null);\n\n          if (hasError) {\n            error(`Patch ${JSON.stringify(action.patch)} apply failed`);\n            return WithError(oldState, UpdateErrorType.PatchFailed, patchError);\n          } else {\n            return newState;\n          }\n        }\n\n      default:\n        {\n          return state;\n        }\n    }\n  };\n}\n\nexport { CreateGameReducer as C, IsLongFormMove as I, ProcessGameConfig as P, TransientHandlingMiddleware as T };","map":{"version":3,"sources":["/Users/andywang/Desktop/CS161_Breadsticks/node_modules/boardgame.io/dist/esm/reducer-07c7b307.js"],"names":["e","error","G","GameMethod","E","EnhanceCtx","T","TurnOrder","a","supportDeprecatedMoveLimit","S","Stage","b","SetActivePlayers","i","info","F","FnWrap","I","InitTurnOrderState","U","UpdateTurnOrderState","c","UpdateActivePlayersOnceEmpty","g","gameEvent","P","PATCH","d","PLUGIN","f","ProcessAction","R","REDO","h","UNDO","j","SYNC","k","UPDATE","l","RESET","M","MAKE_MOVE","m","Enhance","n","INVALID_MOVE","N","NoClient","o","GAME_EVENT","p","STRIP_TRANSIENTS","q","FlushAndValidate","r","stripTransients","applyPatch","Flow","moves","phases","endIf","onEnd","turn","events","plugins","undefined","phaseMap","moveMap","moveNames","Set","startingPhase","Object","keys","forEach","name","add","HookWrapper","hook","hookType","withPlugins","state","ctxWithAPI","TriggerWrapper","trigger","wrapped","GAME_ON_END","phase","phaseConfig","start","move","onBegin","order","DEFAULT","onMove","stages","stage","stageConfig","key","PHASE_ON_BEGIN","PHASE_ON_END","TURN_ON_MOVE","TURN_ON_BEGIN","TURN_ON_END","next","GetPhase","ctx","OnMove","s","Process","phasesEnded","turnsEnded","length","fn","arg","rest","EndPhase","clear","has","EndGame","shouldEndGame","ShouldEndGame","push","automatic","shouldEndPhase","ShouldEndPhase","UpdateStage","UpdateActivePlayers","includes","shouldEndTurn","ShouldEndTurn","EndTurn","StartGame","StartPhase","StartTurn","currentPlayer","activePlayers","numMoves","_prevActivePlayers","_undo","_redo","UpdatePhase","UpdateTurn","endPhase","newCtx","playerID","NULL","_activePlayersMinMoves","_activePlayersMaxMoves","_activePlayersNumMoves","minMoves","maxMoves","currentPlayerMoves","gameover","initialTurn","force","action","_stateID","logEntry","deltalog","remove","playOrder","filter","playOrderPos","EndStage","playerInStage","GetMove","ProcessMove","type","shouldCount","noLimit","SetStageEvent","EndStageEvent","SetActivePlayersEvent","_playerID","SetPhaseEvent","newPhase","EndPhaseEvent","EndTurnEvent","PassEvent","EndGameEvent","eventHandlers","endStage","setStage","endTurn","pass","setPhase","endGame","setActivePlayers","enabledEventNames","ProcessEvent","args","payload","Array","isArray","IsPlayerActive","_G","numPlayers","from","map","_","init","isPlayerActive","eventNames","values","processMove","processEvent","getMove","IsProcessed","game","ProcessGameConfig","deltaState","disableUndo","setup","playerView","plugin","Error","flow","pluginNames","moveFn","IsLongFormMove","Function","MOVE","UpdateErrorType","ActionErrorType","actionHasPlayerID","CanUndoMove","HasUndoable","undoable","IsFunction","updateUndoRedoState","opts","undoEntry","moveType","initializeDeltalog","pluginLogMetadata","log","data","metadata","redact","flushAndValidatePlugins","oldState","pluginOpts","newState","isInvalid","WithError","PluginActionInvalid","ExtractTransients","transientState","transients","errorType","TransientHandlingMiddleware","store","result","getState","dispatch","CreateGameReducer","isClient","stateWithTransients","GameOver","InactivePlayer","stateWithError","UnavailableMove","client","InvalidMove","ActionDisabled","ActionInvalid","last","restore","lastMove","slice","first","JSON","parse","stringify","patchError","patch","hasError","some","entry","PatchFailed","C"],"mappings":"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","sourcesContent":["import { e as error, G as GameMethod, E as EnhanceCtx, T as TurnOrder, a as supportDeprecatedMoveLimit, S as Stage, b as SetActivePlayers, i as info, F as FnWrap, I as InitTurnOrderState, U as UpdateTurnOrderState, c as UpdateActivePlayersOnceEmpty, g as gameEvent, P as PATCH, d as PLUGIN, f as ProcessAction, R as REDO, h as UNDO, j as SYNC, k as UPDATE, l as RESET, M as MAKE_MOVE, m as Enhance, n as INVALID_MOVE, N as NoClient, o as GAME_EVENT, p as STRIP_TRANSIENTS, q as FlushAndValidate, r as stripTransients } from './turn-order-0b7dce3d.js';\nimport { applyPatch } from 'rfc6902';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Flow\r\n *\r\n * Creates a reducer that updates ctx (analogous to how moves update G).\r\n */\r\nfunction Flow({ moves, phases, endIf, onEnd, turn, events, plugins, }) {\r\n    // Attach defaults.\r\n    if (moves === undefined) {\r\n        moves = {};\r\n    }\r\n    if (events === undefined) {\r\n        events = {};\r\n    }\r\n    if (plugins === undefined) {\r\n        plugins = [];\r\n    }\r\n    if (phases === undefined) {\r\n        phases = {};\r\n    }\r\n    if (!endIf)\r\n        endIf = () => undefined;\r\n    if (!onEnd)\r\n        onEnd = (G) => G;\r\n    if (!turn)\r\n        turn = {};\r\n    const phaseMap = { ...phases };\r\n    if ('' in phaseMap) {\r\n        error('cannot specify phase with empty name');\r\n    }\r\n    phaseMap[''] = {};\r\n    const moveMap = {};\r\n    const moveNames = new Set();\r\n    let startingPhase = null;\r\n    Object.keys(moves).forEach((name) => moveNames.add(name));\r\n    const HookWrapper = (hook, hookType) => {\r\n        const withPlugins = FnWrap(hook, hookType, plugins);\r\n        return (state) => {\r\n            const ctxWithAPI = EnhanceCtx(state);\r\n            return withPlugins(state.G, ctxWithAPI);\r\n        };\r\n    };\r\n    const TriggerWrapper = (trigger) => {\r\n        return (state) => {\r\n            const ctxWithAPI = EnhanceCtx(state);\r\n            return trigger(state.G, ctxWithAPI);\r\n        };\r\n    };\r\n    const wrapped = {\r\n        onEnd: HookWrapper(onEnd, GameMethod.GAME_ON_END),\r\n        endIf: TriggerWrapper(endIf),\r\n    };\r\n    for (const phase in phaseMap) {\r\n        const phaseConfig = phaseMap[phase];\r\n        if (phaseConfig.start === true) {\r\n            startingPhase = phase;\r\n        }\r\n        if (phaseConfig.moves !== undefined) {\r\n            for (const move of Object.keys(phaseConfig.moves)) {\r\n                moveMap[phase + '.' + move] = phaseConfig.moves[move];\r\n                moveNames.add(move);\r\n            }\r\n        }\r\n        if (phaseConfig.endIf === undefined) {\r\n            phaseConfig.endIf = () => undefined;\r\n        }\r\n        if (phaseConfig.onBegin === undefined) {\r\n            phaseConfig.onBegin = (G) => G;\r\n        }\r\n        if (phaseConfig.onEnd === undefined) {\r\n            phaseConfig.onEnd = (G) => G;\r\n        }\r\n        if (phaseConfig.turn === undefined) {\r\n            phaseConfig.turn = turn;\r\n        }\r\n        if (phaseConfig.turn.order === undefined) {\r\n            phaseConfig.turn.order = TurnOrder.DEFAULT;\r\n        }\r\n        if (phaseConfig.turn.onBegin === undefined) {\r\n            phaseConfig.turn.onBegin = (G) => G;\r\n        }\r\n        if (phaseConfig.turn.onEnd === undefined) {\r\n            phaseConfig.turn.onEnd = (G) => G;\r\n        }\r\n        if (phaseConfig.turn.endIf === undefined) {\r\n            phaseConfig.turn.endIf = () => false;\r\n        }\r\n        if (phaseConfig.turn.onMove === undefined) {\r\n            phaseConfig.turn.onMove = (G) => G;\r\n        }\r\n        if (phaseConfig.turn.stages === undefined) {\r\n            phaseConfig.turn.stages = {};\r\n        }\r\n        // turns previously treated moveLimit as both minMoves and maxMoves, this behaviour is kept intentionally\r\n        supportDeprecatedMoveLimit(phaseConfig.turn, true);\r\n        for (const stage in phaseConfig.turn.stages) {\r\n            const stageConfig = phaseConfig.turn.stages[stage];\r\n            const moves = stageConfig.moves || {};\r\n            for (const move of Object.keys(moves)) {\r\n                const key = phase + '.' + stage + '.' + move;\r\n                moveMap[key] = moves[move];\r\n                moveNames.add(move);\r\n            }\r\n        }\r\n        phaseConfig.wrapped = {\r\n            onBegin: HookWrapper(phaseConfig.onBegin, GameMethod.PHASE_ON_BEGIN),\r\n            onEnd: HookWrapper(phaseConfig.onEnd, GameMethod.PHASE_ON_END),\r\n            endIf: TriggerWrapper(phaseConfig.endIf),\r\n        };\r\n        phaseConfig.turn.wrapped = {\r\n            onMove: HookWrapper(phaseConfig.turn.onMove, GameMethod.TURN_ON_MOVE),\r\n            onBegin: HookWrapper(phaseConfig.turn.onBegin, GameMethod.TURN_ON_BEGIN),\r\n            onEnd: HookWrapper(phaseConfig.turn.onEnd, GameMethod.TURN_ON_END),\r\n            endIf: TriggerWrapper(phaseConfig.turn.endIf),\r\n        };\r\n        if (typeof phaseConfig.next !== 'function') {\r\n            const { next } = phaseConfig;\r\n            phaseConfig.next = () => next || null;\r\n        }\r\n        phaseConfig.wrapped.next = TriggerWrapper(phaseConfig.next);\r\n    }\r\n    function GetPhase(ctx) {\r\n        return ctx.phase ? phaseMap[ctx.phase] : phaseMap[''];\r\n    }\r\n    function OnMove(s) {\r\n        return s;\r\n    }\r\n    function Process(state, events) {\r\n        const phasesEnded = new Set();\r\n        const turnsEnded = new Set();\r\n        for (let i = 0; i < events.length; i++) {\r\n            const { fn, arg, ...rest } = events[i];\r\n            // Detect a loop of EndPhase calls.\r\n            // This could potentially even be an infinite loop\r\n            // if the endIf condition of each phase blindly\r\n            // returns true. The moment we detect a single\r\n            // loop, we just bail out of all phases.\r\n            if (fn === EndPhase) {\r\n                turnsEnded.clear();\r\n                const phase = state.ctx.phase;\r\n                if (phasesEnded.has(phase)) {\r\n                    const ctx = { ...state.ctx, phase: null };\r\n                    return { ...state, ctx };\r\n                }\r\n                phasesEnded.add(phase);\r\n            }\r\n            // Process event.\r\n            const next = [];\r\n            state = fn(state, {\r\n                ...rest,\r\n                arg,\r\n                next,\r\n            });\r\n            if (fn === EndGame) {\r\n                break;\r\n            }\r\n            // Check if we should end the game.\r\n            const shouldEndGame = ShouldEndGame(state);\r\n            if (shouldEndGame) {\r\n                events.push({\r\n                    fn: EndGame,\r\n                    arg: shouldEndGame,\r\n                    turn: state.ctx.turn,\r\n                    phase: state.ctx.phase,\r\n                    automatic: true,\r\n                });\r\n                continue;\r\n            }\r\n            // Check if we should end the phase.\r\n            const shouldEndPhase = ShouldEndPhase(state);\r\n            if (shouldEndPhase) {\r\n                events.push({\r\n                    fn: EndPhase,\r\n                    arg: shouldEndPhase,\r\n                    turn: state.ctx.turn,\r\n                    phase: state.ctx.phase,\r\n                    automatic: true,\r\n                });\r\n                continue;\r\n            }\r\n            // Check if we should end the turn.\r\n            if ([OnMove, UpdateStage, UpdateActivePlayers].includes(fn)) {\r\n                const shouldEndTurn = ShouldEndTurn(state);\r\n                if (shouldEndTurn) {\r\n                    events.push({\r\n                        fn: EndTurn,\r\n                        arg: shouldEndTurn,\r\n                        turn: state.ctx.turn,\r\n                        phase: state.ctx.phase,\r\n                        automatic: true,\r\n                    });\r\n                    continue;\r\n                }\r\n            }\r\n            events.push(...next);\r\n        }\r\n        return state;\r\n    }\r\n    ///////////\r\n    // Start //\r\n    ///////////\r\n    function StartGame(state, { next }) {\r\n        next.push({ fn: StartPhase });\r\n        return state;\r\n    }\r\n    function StartPhase(state, { next }) {\r\n        let { G, ctx } = state;\r\n        const phaseConfig = GetPhase(ctx);\r\n        // Run any phase setup code provided by the user.\r\n        G = phaseConfig.wrapped.onBegin(state);\r\n        next.push({ fn: StartTurn });\r\n        return { ...state, G, ctx };\r\n    }\r\n    function StartTurn(state, { currentPlayer }) {\r\n        let { ctx } = state;\r\n        const phaseConfig = GetPhase(ctx);\r\n        // Initialize the turn order state.\r\n        if (currentPlayer) {\r\n            ctx = { ...ctx, currentPlayer };\r\n            if (phaseConfig.turn.activePlayers) {\r\n                ctx = SetActivePlayers(ctx, phaseConfig.turn.activePlayers);\r\n            }\r\n        }\r\n        else {\r\n            // This is only called at the beginning of the phase\r\n            // when there is no currentPlayer yet.\r\n            ctx = InitTurnOrderState(state, phaseConfig.turn);\r\n        }\r\n        const turn = ctx.turn + 1;\r\n        ctx = { ...ctx, turn, numMoves: 0, _prevActivePlayers: [] };\r\n        const G = phaseConfig.turn.wrapped.onBegin({ ...state, ctx });\r\n        return { ...state, G, ctx, _undo: [], _redo: [] };\r\n    }\r\n    ////////////\r\n    // Update //\r\n    ////////////\r\n    function UpdatePhase(state, { arg, next, phase }) {\r\n        const phaseConfig = GetPhase({ phase });\r\n        let { ctx } = state;\r\n        if (arg && arg.next) {\r\n            if (arg.next in phaseMap) {\r\n                ctx = { ...ctx, phase: arg.next };\r\n            }\r\n            else {\r\n                error('invalid phase: ' + arg.next);\r\n                return state;\r\n            }\r\n        }\r\n        else {\r\n            ctx = { ...ctx, phase: phaseConfig.wrapped.next(state) || null };\r\n        }\r\n        state = { ...state, ctx };\r\n        // Start the new phase.\r\n        next.push({ fn: StartPhase });\r\n        return state;\r\n    }\r\n    function UpdateTurn(state, { arg, currentPlayer, next }) {\r\n        let { G, ctx } = state;\r\n        const phaseConfig = GetPhase(ctx);\r\n        // Update turn order state.\r\n        const { endPhase, ctx: newCtx } = UpdateTurnOrderState(state, currentPlayer, phaseConfig.turn, arg);\r\n        ctx = newCtx;\r\n        state = { ...state, G, ctx };\r\n        if (endPhase) {\r\n            next.push({ fn: EndPhase, turn: ctx.turn, phase: ctx.phase });\r\n        }\r\n        else {\r\n            next.push({ fn: StartTurn, currentPlayer: ctx.currentPlayer });\r\n        }\r\n        return state;\r\n    }\r\n    function UpdateStage(state, { arg, playerID }) {\r\n        if (typeof arg === 'string' || arg === Stage.NULL) {\r\n            arg = { stage: arg };\r\n        }\r\n        if (typeof arg !== 'object')\r\n            return state;\r\n        // `arg` should be of type `StageArg`, loose typing as `any` here for historic reasons\r\n        // stages previously did not enforce minMoves, this behaviour is kept intentionally\r\n        supportDeprecatedMoveLimit(arg);\r\n        let { ctx } = state;\r\n        let { activePlayers, _activePlayersMinMoves, _activePlayersMaxMoves, _activePlayersNumMoves, } = ctx;\r\n        // Checking if stage is valid, even Stage.NULL\r\n        if (arg.stage !== undefined) {\r\n            if (activePlayers === null) {\r\n                activePlayers = {};\r\n            }\r\n            activePlayers[playerID] = arg.stage;\r\n            _activePlayersNumMoves[playerID] = 0;\r\n            if (arg.minMoves) {\r\n                if (_activePlayersMinMoves === null) {\r\n                    _activePlayersMinMoves = {};\r\n                }\r\n                _activePlayersMinMoves[playerID] = arg.minMoves;\r\n            }\r\n            if (arg.maxMoves) {\r\n                if (_activePlayersMaxMoves === null) {\r\n                    _activePlayersMaxMoves = {};\r\n                }\r\n                _activePlayersMaxMoves[playerID] = arg.maxMoves;\r\n            }\r\n        }\r\n        ctx = {\r\n            ...ctx,\r\n            activePlayers,\r\n            _activePlayersMinMoves,\r\n            _activePlayersMaxMoves,\r\n            _activePlayersNumMoves,\r\n        };\r\n        return { ...state, ctx };\r\n    }\r\n    function UpdateActivePlayers(state, { arg }) {\r\n        return { ...state, ctx: SetActivePlayers(state.ctx, arg) };\r\n    }\r\n    ///////////////\r\n    // ShouldEnd //\r\n    ///////////////\r\n    function ShouldEndGame(state) {\r\n        return wrapped.endIf(state);\r\n    }\r\n    function ShouldEndPhase(state) {\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        return phaseConfig.wrapped.endIf(state);\r\n    }\r\n    function ShouldEndTurn(state) {\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        // End the turn if the required number of moves has been made.\r\n        const currentPlayerMoves = state.ctx.numMoves || 0;\r\n        if (phaseConfig.turn.maxMoves &&\r\n            currentPlayerMoves >= phaseConfig.turn.maxMoves) {\r\n            return true;\r\n        }\r\n        return phaseConfig.turn.wrapped.endIf(state);\r\n    }\r\n    /////////\r\n    // End //\r\n    /////////\r\n    function EndGame(state, { arg, phase }) {\r\n        state = EndPhase(state, { phase });\r\n        if (arg === undefined) {\r\n            arg = true;\r\n        }\r\n        state = { ...state, ctx: { ...state.ctx, gameover: arg } };\r\n        // Run game end hook.\r\n        const G = wrapped.onEnd(state);\r\n        return { ...state, G };\r\n    }\r\n    function EndPhase(state, { arg, next, turn: initialTurn, automatic }) {\r\n        // End the turn first.\r\n        state = EndTurn(state, { turn: initialTurn, force: true, automatic: true });\r\n        const { phase, turn } = state.ctx;\r\n        if (next) {\r\n            next.push({ fn: UpdatePhase, arg, phase });\r\n        }\r\n        // If we aren't in a phase, there is nothing else to do.\r\n        if (phase === null) {\r\n            return state;\r\n        }\r\n        // Run any cleanup code for the phase that is about to end.\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        const G = phaseConfig.wrapped.onEnd(state);\r\n        // Reset the phase.\r\n        const ctx = { ...state.ctx, phase: null };\r\n        // Add log entry.\r\n        const action = gameEvent('endPhase', arg);\r\n        const { _stateID } = state;\r\n        const logEntry = { action, _stateID, turn, phase };\r\n        if (automatic)\r\n            logEntry.automatic = true;\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, G, ctx, deltalog };\r\n    }\r\n    function EndTurn(state, { arg, next, turn: initialTurn, force, automatic, playerID }) {\r\n        // This is not the turn that EndTurn was originally\r\n        // called for. The turn was probably ended some other way.\r\n        if (initialTurn !== state.ctx.turn) {\r\n            return state;\r\n        }\r\n        const { currentPlayer, numMoves, phase, turn } = state.ctx;\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        // Prevent ending the turn if minMoves haven't been reached.\r\n        const currentPlayerMoves = numMoves || 0;\r\n        if (!force &&\r\n            phaseConfig.turn.minMoves &&\r\n            currentPlayerMoves < phaseConfig.turn.minMoves) {\r\n            info(`cannot end turn before making ${phaseConfig.turn.minMoves} moves`);\r\n            return state;\r\n        }\r\n        // Run turn-end triggers.\r\n        const G = phaseConfig.turn.wrapped.onEnd(state);\r\n        if (next) {\r\n            next.push({ fn: UpdateTurn, arg, currentPlayer });\r\n        }\r\n        // Reset activePlayers.\r\n        let ctx = { ...state.ctx, activePlayers: null };\r\n        // Remove player from playerOrder\r\n        if (arg && arg.remove) {\r\n            playerID = playerID || currentPlayer;\r\n            const playOrder = ctx.playOrder.filter((i) => i != playerID);\r\n            const playOrderPos = ctx.playOrderPos > playOrder.length - 1 ? 0 : ctx.playOrderPos;\r\n            ctx = { ...ctx, playOrder, playOrderPos };\r\n            if (playOrder.length === 0) {\r\n                next.push({ fn: EndPhase, turn, phase });\r\n                return state;\r\n            }\r\n        }\r\n        // Create log entry.\r\n        const action = gameEvent('endTurn', arg);\r\n        const { _stateID } = state;\r\n        const logEntry = { action, _stateID, turn, phase };\r\n        if (automatic)\r\n            logEntry.automatic = true;\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, G, ctx, deltalog, _undo: [], _redo: [] };\r\n    }\r\n    function EndStage(state, { arg, next, automatic, playerID }) {\r\n        playerID = playerID || state.ctx.currentPlayer;\r\n        let { ctx, _stateID } = state;\r\n        let { activePlayers, _activePlayersNumMoves, _activePlayersMinMoves, _activePlayersMaxMoves, phase, turn, } = ctx;\r\n        const playerInStage = activePlayers !== null && playerID in activePlayers;\r\n        const phaseConfig = GetPhase(ctx);\r\n        if (!arg && playerInStage) {\r\n            const stage = phaseConfig.turn.stages[activePlayers[playerID]];\r\n            if (stage && stage.next) {\r\n                arg = stage.next;\r\n            }\r\n        }\r\n        // Checking if arg is a valid stage, even Stage.NULL\r\n        if (next) {\r\n            next.push({ fn: UpdateStage, arg, playerID });\r\n        }\r\n        // If player isn’t in a stage, there is nothing else to do.\r\n        if (!playerInStage)\r\n            return state;\r\n        // Prevent ending the stage if minMoves haven't been reached.\r\n        const currentPlayerMoves = _activePlayersNumMoves[playerID] || 0;\r\n        if (_activePlayersMinMoves &&\r\n            _activePlayersMinMoves[playerID] &&\r\n            currentPlayerMoves < _activePlayersMinMoves[playerID]) {\r\n            info(`cannot end stage before making ${_activePlayersMinMoves[playerID]} moves`);\r\n            return state;\r\n        }\r\n        // Remove player from activePlayers.\r\n        activePlayers = { ...activePlayers };\r\n        delete activePlayers[playerID];\r\n        if (_activePlayersMinMoves) {\r\n            // Remove player from _activePlayersMinMoves.\r\n            _activePlayersMinMoves = { ..._activePlayersMinMoves };\r\n            delete _activePlayersMinMoves[playerID];\r\n        }\r\n        if (_activePlayersMaxMoves) {\r\n            // Remove player from _activePlayersMaxMoves.\r\n            _activePlayersMaxMoves = { ..._activePlayersMaxMoves };\r\n            delete _activePlayersMaxMoves[playerID];\r\n        }\r\n        ctx = UpdateActivePlayersOnceEmpty({\r\n            ...ctx,\r\n            activePlayers,\r\n            _activePlayersMinMoves,\r\n            _activePlayersMaxMoves,\r\n        });\r\n        // Create log entry.\r\n        const action = gameEvent('endStage', arg);\r\n        const logEntry = { action, _stateID, turn, phase };\r\n        if (automatic)\r\n            logEntry.automatic = true;\r\n        const deltalog = [...(state.deltalog || []), logEntry];\r\n        return { ...state, ctx, deltalog };\r\n    }\r\n    /**\r\n     * Retrieves the relevant move that can be played by playerID.\r\n     *\r\n     * If ctx.activePlayers is set (i.e. one or more players are in some stage),\r\n     * then it attempts to find the move inside the stages config for\r\n     * that turn. If the stage for a player is '', then the player is\r\n     * allowed to make a move (as determined by the phase config), but\r\n     * isn't restricted to a particular set as defined in the stage config.\r\n     *\r\n     * If not, it then looks for the move inside the phase.\r\n     *\r\n     * If it doesn't find the move there, it looks at the global move definition.\r\n     *\r\n     * @param {object} ctx\r\n     * @param {string} name\r\n     * @param {string} playerID\r\n     */\r\n    function GetMove(ctx, name, playerID) {\r\n        const phaseConfig = GetPhase(ctx);\r\n        const stages = phaseConfig.turn.stages;\r\n        const { activePlayers } = ctx;\r\n        if (activePlayers &&\r\n            activePlayers[playerID] !== undefined &&\r\n            activePlayers[playerID] !== Stage.NULL &&\r\n            stages[activePlayers[playerID]] !== undefined &&\r\n            stages[activePlayers[playerID]].moves !== undefined) {\r\n            // Check if moves are defined for the player's stage.\r\n            const stage = stages[activePlayers[playerID]];\r\n            const moves = stage.moves;\r\n            if (name in moves) {\r\n                return moves[name];\r\n            }\r\n        }\r\n        else if (phaseConfig.moves) {\r\n            // Check if moves are defined for the current phase.\r\n            if (name in phaseConfig.moves) {\r\n                return phaseConfig.moves[name];\r\n            }\r\n        }\r\n        else if (name in moves) {\r\n            // Check for the move globally.\r\n            return moves[name];\r\n        }\r\n        return null;\r\n    }\r\n    function ProcessMove(state, action) {\r\n        const { playerID, type } = action;\r\n        const { currentPlayer, activePlayers, _activePlayersMaxMoves } = state.ctx;\r\n        const move = GetMove(state.ctx, type, playerID);\r\n        const shouldCount = !move || typeof move === 'function' || move.noLimit !== true;\r\n        let { numMoves, _activePlayersNumMoves } = state.ctx;\r\n        if (shouldCount) {\r\n            if (playerID === currentPlayer)\r\n                numMoves++;\r\n            if (activePlayers)\r\n                _activePlayersNumMoves[playerID]++;\r\n        }\r\n        state = {\r\n            ...state,\r\n            ctx: {\r\n                ...state.ctx,\r\n                numMoves,\r\n                _activePlayersNumMoves,\r\n            },\r\n        };\r\n        if (_activePlayersMaxMoves &&\r\n            _activePlayersNumMoves[playerID] >= _activePlayersMaxMoves[playerID]) {\r\n            state = EndStage(state, { playerID, automatic: true });\r\n        }\r\n        const phaseConfig = GetPhase(state.ctx);\r\n        const G = phaseConfig.turn.wrapped.onMove({\r\n            ...state,\r\n            ctx: { ...state.ctx, playerID },\r\n        });\r\n        state = { ...state, G };\r\n        const events = [{ fn: OnMove }];\r\n        return Process(state, events);\r\n    }\r\n    function SetStageEvent(state, playerID, arg) {\r\n        return Process(state, [{ fn: EndStage, arg, playerID }]);\r\n    }\r\n    function EndStageEvent(state, playerID) {\r\n        return Process(state, [{ fn: EndStage, playerID }]);\r\n    }\r\n    function SetActivePlayersEvent(state, _playerID, arg) {\r\n        return Process(state, [{ fn: UpdateActivePlayers, arg }]);\r\n    }\r\n    function SetPhaseEvent(state, _playerID, newPhase) {\r\n        return Process(state, [\r\n            {\r\n                fn: EndPhase,\r\n                phase: state.ctx.phase,\r\n                turn: state.ctx.turn,\r\n                arg: { next: newPhase },\r\n            },\r\n        ]);\r\n    }\r\n    function EndPhaseEvent(state) {\r\n        return Process(state, [\r\n            { fn: EndPhase, phase: state.ctx.phase, turn: state.ctx.turn },\r\n        ]);\r\n    }\r\n    function EndTurnEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            { fn: EndTurn, turn: state.ctx.turn, phase: state.ctx.phase, arg },\r\n        ]);\r\n    }\r\n    function PassEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            {\r\n                fn: EndTurn,\r\n                turn: state.ctx.turn,\r\n                phase: state.ctx.phase,\r\n                force: true,\r\n                arg,\r\n            },\r\n        ]);\r\n    }\r\n    function EndGameEvent(state, _playerID, arg) {\r\n        return Process(state, [\r\n            { fn: EndGame, turn: state.ctx.turn, phase: state.ctx.phase, arg },\r\n        ]);\r\n    }\r\n    const eventHandlers = {\r\n        endStage: EndStageEvent,\r\n        setStage: SetStageEvent,\r\n        endTurn: EndTurnEvent,\r\n        pass: PassEvent,\r\n        endPhase: EndPhaseEvent,\r\n        setPhase: SetPhaseEvent,\r\n        endGame: EndGameEvent,\r\n        setActivePlayers: SetActivePlayersEvent,\r\n    };\r\n    const enabledEventNames = [];\r\n    if (events.endTurn !== false) {\r\n        enabledEventNames.push('endTurn');\r\n    }\r\n    if (events.pass !== false) {\r\n        enabledEventNames.push('pass');\r\n    }\r\n    if (events.endPhase !== false) {\r\n        enabledEventNames.push('endPhase');\r\n    }\r\n    if (events.setPhase !== false) {\r\n        enabledEventNames.push('setPhase');\r\n    }\r\n    if (events.endGame !== false) {\r\n        enabledEventNames.push('endGame');\r\n    }\r\n    if (events.setActivePlayers !== false) {\r\n        enabledEventNames.push('setActivePlayers');\r\n    }\r\n    if (events.endStage !== false) {\r\n        enabledEventNames.push('endStage');\r\n    }\r\n    if (events.setStage !== false) {\r\n        enabledEventNames.push('setStage');\r\n    }\r\n    function ProcessEvent(state, action) {\r\n        const { type, playerID, args } = action.payload;\r\n        if (typeof eventHandlers[type] !== 'function')\r\n            return state;\r\n        return eventHandlers[type](state, playerID, ...(Array.isArray(args) ? args : [args]));\r\n    }\r\n    function IsPlayerActive(_G, ctx, playerID) {\r\n        if (ctx.activePlayers) {\r\n            return playerID in ctx.activePlayers;\r\n        }\r\n        return ctx.currentPlayer === playerID;\r\n    }\r\n    return {\r\n        ctx: (numPlayers) => ({\r\n            numPlayers,\r\n            turn: 0,\r\n            currentPlayer: '0',\r\n            playOrder: [...Array.from({ length: numPlayers })].map((_, i) => i + ''),\r\n            playOrderPos: 0,\r\n            phase: startingPhase,\r\n            activePlayers: null,\r\n        }),\r\n        init: (state) => {\r\n            return Process(state, [{ fn: StartGame }]);\r\n        },\r\n        isPlayerActive: IsPlayerActive,\r\n        eventHandlers,\r\n        eventNames: Object.keys(eventHandlers),\r\n        enabledEventNames,\r\n        moveMap,\r\n        moveNames: [...moveNames.values()],\r\n        processMove: ProcessMove,\r\n        processEvent: ProcessEvent,\r\n        getMove: GetMove,\r\n    };\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nfunction IsProcessed(game) {\r\n    return game.processMove !== undefined;\r\n}\r\n/**\r\n * Helper to generate the game move reducer. The returned\r\n * reducer has the following signature:\r\n *\r\n * (G, action, ctx) => {}\r\n *\r\n * You can roll your own if you like, or use any Redux\r\n * addon to generate such a reducer.\r\n *\r\n * The convention used in this framework is to\r\n * have action.type contain the name of the move, and\r\n * action.args contain any additional arguments as an\r\n * Array.\r\n */\r\nfunction ProcessGameConfig(game) {\r\n    // The Game() function has already been called on this\r\n    // config object, so just pass it through.\r\n    if (IsProcessed(game)) {\r\n        return game;\r\n    }\r\n    if (game.name === undefined)\r\n        game.name = 'default';\r\n    if (game.deltaState === undefined)\r\n        game.deltaState = false;\r\n    if (game.disableUndo === undefined)\r\n        game.disableUndo = false;\r\n    if (game.setup === undefined)\r\n        game.setup = () => ({});\r\n    if (game.moves === undefined)\r\n        game.moves = {};\r\n    if (game.playerView === undefined)\r\n        game.playerView = (G) => G;\r\n    if (game.plugins === undefined)\r\n        game.plugins = [];\r\n    game.plugins.forEach((plugin) => {\r\n        if (plugin.name === undefined) {\r\n            throw new Error('Plugin missing name attribute');\r\n        }\r\n        if (plugin.name.includes(' ')) {\r\n            throw new Error(plugin.name + ': Plugin name must not include spaces');\r\n        }\r\n    });\r\n    if (game.name.includes(' ')) {\r\n        throw new Error(game.name + ': Game name must not include spaces');\r\n    }\r\n    const flow = Flow(game);\r\n    return {\r\n        ...game,\r\n        flow,\r\n        moveNames: flow.moveNames,\r\n        pluginNames: game.plugins.map((p) => p.name),\r\n        processMove: (state, action) => {\r\n            let moveFn = flow.getMove(state.ctx, action.type, action.playerID);\r\n            if (IsLongFormMove(moveFn)) {\r\n                moveFn = moveFn.move;\r\n            }\r\n            if (moveFn instanceof Function) {\r\n                const fn = FnWrap(moveFn, GameMethod.MOVE, game.plugins);\r\n                const ctxWithAPI = {\r\n                    ...EnhanceCtx(state),\r\n                    playerID: action.playerID,\r\n                };\r\n                let args = [];\r\n                if (action.args !== undefined) {\r\n                    args = Array.isArray(action.args) ? action.args : [action.args];\r\n                }\r\n                return fn(state.G, ctxWithAPI, ...args);\r\n            }\r\n            error(`invalid move object: ${action.type}`);\r\n            return state.G;\r\n        },\r\n    };\r\n}\r\nfunction IsLongFormMove(move) {\r\n    return move instanceof Object && move.move !== undefined;\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nvar UpdateErrorType;\r\n(function (UpdateErrorType) {\r\n    // The action’s credentials were missing or invalid\r\n    UpdateErrorType[\"UnauthorizedAction\"] = \"update/unauthorized_action\";\r\n    // The action’s matchID was not found\r\n    UpdateErrorType[\"MatchNotFound\"] = \"update/match_not_found\";\r\n    // Could not apply Patch operation (rfc6902).\r\n    UpdateErrorType[\"PatchFailed\"] = \"update/patch_failed\";\r\n})(UpdateErrorType || (UpdateErrorType = {}));\r\nvar ActionErrorType;\r\n(function (ActionErrorType) {\r\n    // The action contained a stale state ID\r\n    ActionErrorType[\"StaleStateId\"] = \"action/stale_state_id\";\r\n    // The requested move is unknown or not currently available\r\n    ActionErrorType[\"UnavailableMove\"] = \"action/unavailable_move\";\r\n    // The move declared it was invalid (INVALID_MOVE constant)\r\n    ActionErrorType[\"InvalidMove\"] = \"action/invalid_move\";\r\n    // The player making the action is not currently active\r\n    ActionErrorType[\"InactivePlayer\"] = \"action/inactive_player\";\r\n    // The game has finished\r\n    ActionErrorType[\"GameOver\"] = \"action/gameover\";\r\n    // The requested action is disabled (e.g. undo/redo, events)\r\n    ActionErrorType[\"ActionDisabled\"] = \"action/action_disabled\";\r\n    // The requested action is not currently possible\r\n    ActionErrorType[\"ActionInvalid\"] = \"action/action_invalid\";\r\n    // The requested action was declared invalid by a plugin\r\n    ActionErrorType[\"PluginActionInvalid\"] = \"action/plugin_invalid\";\r\n})(ActionErrorType || (ActionErrorType = {}));\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Check if the payload for the passed action contains a playerID.\r\n */\r\nconst actionHasPlayerID = (action) => action.payload.playerID !== null && action.payload.playerID !== undefined;\r\n/**\r\n * Returns true if a move can be undone.\r\n */\r\nconst CanUndoMove = (G, ctx, move) => {\r\n    function HasUndoable(move) {\r\n        return move.undoable !== undefined;\r\n    }\r\n    function IsFunction(undoable) {\r\n        return undoable instanceof Function;\r\n    }\r\n    if (!HasUndoable(move)) {\r\n        return true;\r\n    }\r\n    if (IsFunction(move.undoable)) {\r\n        return move.undoable(G, ctx);\r\n    }\r\n    return move.undoable;\r\n};\r\n/**\r\n * Update the undo and redo stacks for a move or event.\r\n */\r\nfunction updateUndoRedoState(state, opts) {\r\n    if (opts.game.disableUndo)\r\n        return state;\r\n    const undoEntry = {\r\n        G: state.G,\r\n        ctx: state.ctx,\r\n        plugins: state.plugins,\r\n        playerID: opts.action.payload.playerID || state.ctx.currentPlayer,\r\n    };\r\n    if (opts.action.type === 'MAKE_MOVE') {\r\n        undoEntry.moveType = opts.action.payload.type;\r\n    }\r\n    return {\r\n        ...state,\r\n        _undo: [...state._undo, undoEntry],\r\n        // Always reset redo stack when making a move or event\r\n        _redo: [],\r\n    };\r\n}\r\n/**\r\n * Process state, adding the initial deltalog for this action.\r\n */\r\nfunction initializeDeltalog(state, action, move) {\r\n    // Create a log entry for this action.\r\n    const logEntry = {\r\n        action,\r\n        _stateID: state._stateID,\r\n        turn: state.ctx.turn,\r\n        phase: state.ctx.phase,\r\n    };\r\n    const pluginLogMetadata = state.plugins.log.data.metadata;\r\n    if (pluginLogMetadata !== undefined) {\r\n        logEntry.metadata = pluginLogMetadata;\r\n    }\r\n    if (typeof move === 'object' && move.redact === true) {\r\n        logEntry.redact = true;\r\n    }\r\n    return {\r\n        ...state,\r\n        deltalog: [logEntry],\r\n    };\r\n}\r\n/**\r\n * Update plugin state after move/event & check if plugins consider the action to be valid.\r\n * @param state Current version of state in the reducer.\r\n * @param oldState State to revert to in case of error.\r\n * @param pluginOpts Plugin configuration options.\r\n * @returns Tuple of the new state updated after flushing plugins and the old\r\n * state augmented with an error if a plugin declared the action invalid.\r\n */\r\nfunction flushAndValidatePlugins(state, oldState, pluginOpts) {\r\n    const [newState, isInvalid] = FlushAndValidate(state, pluginOpts);\r\n    if (!isInvalid)\r\n        return [newState];\r\n    return [\r\n        newState,\r\n        WithError(oldState, ActionErrorType.PluginActionInvalid, isInvalid),\r\n    ];\r\n}\r\n/**\r\n * ExtractTransientsFromState\r\n *\r\n * Split out transients from the a TransientState\r\n */\r\nfunction ExtractTransients(transientState) {\r\n    if (!transientState) {\r\n        // We preserve null for the state for legacy callers, but the transient\r\n        // field should be undefined if not present to be consistent with the\r\n        // code path below.\r\n        return [null, undefined];\r\n    }\r\n    const { transients, ...state } = transientState;\r\n    return [state, transients];\r\n}\r\n/**\r\n * WithError\r\n *\r\n * Augment a State instance with transient error information.\r\n */\r\nfunction WithError(state, errorType, payload) {\r\n    const error = {\r\n        type: errorType,\r\n        payload,\r\n    };\r\n    return {\r\n        ...state,\r\n        transients: {\r\n            error,\r\n        },\r\n    };\r\n}\r\n/**\r\n * Middleware for processing TransientState associated with the reducer\r\n * returned by CreateGameReducer.\r\n * This should pretty much be used everywhere you want realistic state\r\n * transitions and error handling.\r\n */\r\nconst TransientHandlingMiddleware = (store) => (next) => (action) => {\r\n    const result = next(action);\r\n    switch (action.type) {\r\n        case STRIP_TRANSIENTS: {\r\n            return result;\r\n        }\r\n        default: {\r\n            const [, transients] = ExtractTransients(store.getState());\r\n            if (typeof transients !== 'undefined') {\r\n                store.dispatch(stripTransients());\r\n                // Dev Note: If parent middleware needs to correlate the spawned\r\n                // StripTransients action to the triggering action, instrument here.\r\n                //\r\n                // This is a bit tricky; for more details, see:\r\n                //   https://github.com/boardgameio/boardgame.io/pull/940#discussion_r636200648\r\n                return {\r\n                    ...result,\r\n                    transients,\r\n                };\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n};\r\n/**\r\n * CreateGameReducer\r\n *\r\n * Creates the main game state reducer.\r\n */\r\nfunction CreateGameReducer({ game, isClient, }) {\r\n    game = ProcessGameConfig(game);\r\n    /**\r\n     * GameReducer\r\n     *\r\n     * Redux reducer that maintains the overall game state.\r\n     * @param {object} state - The state before the action.\r\n     * @param {object} action - A Redux action.\r\n     */\r\n    return (stateWithTransients = null, action) => {\r\n        let [state /*, transients */] = ExtractTransients(stateWithTransients);\r\n        switch (action.type) {\r\n            case STRIP_TRANSIENTS: {\r\n                // This action indicates that transient metadata in the state has been\r\n                // consumed and should now be stripped from the state..\r\n                return state;\r\n            }\r\n            case GAME_EVENT: {\r\n                state = { ...state, deltalog: [] };\r\n                // Process game events only on the server.\r\n                // These events like `endTurn` typically\r\n                // contain code that may rely on secret state\r\n                // and cannot be computed on the client.\r\n                if (isClient) {\r\n                    return state;\r\n                }\r\n                // Disallow events once the game is over.\r\n                if (state.ctx.gameover !== undefined) {\r\n                    error(`cannot call event after game end`);\r\n                    return WithError(state, ActionErrorType.GameOver);\r\n                }\r\n                // Ignore the event if the player isn't active.\r\n                if (actionHasPlayerID(action) &&\r\n                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\r\n                    error(`disallowed event: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.InactivePlayer);\r\n                }\r\n                // Execute plugins.\r\n                state = Enhance(state, {\r\n                    game,\r\n                    isClient: false,\r\n                    playerID: action.payload.playerID,\r\n                });\r\n                // Process event.\r\n                let newState = game.flow.processEvent(state, action);\r\n                // Execute plugins.\r\n                let stateWithError;\r\n                [newState, stateWithError] = flushAndValidatePlugins(newState, state, {\r\n                    game,\r\n                    isClient: false,\r\n                });\r\n                if (stateWithError)\r\n                    return stateWithError;\r\n                // Update undo / redo state.\r\n                newState = updateUndoRedoState(newState, { game, action });\r\n                return { ...newState, _stateID: state._stateID + 1 };\r\n            }\r\n            case MAKE_MOVE: {\r\n                const oldState = (state = { ...state, deltalog: [] });\r\n                // Check whether the move is allowed at this time.\r\n                const move = game.flow.getMove(state.ctx, action.payload.type, action.payload.playerID || state.ctx.currentPlayer);\r\n                if (move === null) {\r\n                    error(`disallowed move: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.UnavailableMove);\r\n                }\r\n                // Don't run move on client if move says so.\r\n                if (isClient && move.client === false) {\r\n                    return state;\r\n                }\r\n                // Disallow moves once the game is over.\r\n                if (state.ctx.gameover !== undefined) {\r\n                    error(`cannot make move after game end`);\r\n                    return WithError(state, ActionErrorType.GameOver);\r\n                }\r\n                // Ignore the move if the player isn't active.\r\n                if (actionHasPlayerID(action) &&\r\n                    !game.flow.isPlayerActive(state.G, state.ctx, action.payload.playerID)) {\r\n                    error(`disallowed move: ${action.payload.type}`);\r\n                    return WithError(state, ActionErrorType.InactivePlayer);\r\n                }\r\n                // Execute plugins.\r\n                state = Enhance(state, {\r\n                    game,\r\n                    isClient,\r\n                    playerID: action.payload.playerID,\r\n                });\r\n                // Process the move.\r\n                const G = game.processMove(state, action.payload);\r\n                // The game declared the move as invalid.\r\n                if (G === INVALID_MOVE) {\r\n                    error(`invalid move: ${action.payload.type} args: ${action.payload.args}`);\r\n                    // TODO(#723): Marshal a nice error payload with the processed move.\r\n                    return WithError(state, ActionErrorType.InvalidMove);\r\n                }\r\n                const newState = { ...state, G };\r\n                // Some plugin indicated that it is not suitable to be\r\n                // materialized on the client (and must wait for the server\r\n                // response instead).\r\n                if (isClient && NoClient(newState, { game })) {\r\n                    return state;\r\n                }\r\n                state = newState;\r\n                // If we're on the client, just process the move\r\n                // and no triggers in multiplayer mode.\r\n                // These will be processed on the server, which\r\n                // will send back a state update.\r\n                if (isClient) {\r\n                    let stateWithError;\r\n                    [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\r\n                        game,\r\n                        isClient: true,\r\n                    });\r\n                    if (stateWithError)\r\n                        return stateWithError;\r\n                    return {\r\n                        ...state,\r\n                        _stateID: state._stateID + 1,\r\n                    };\r\n                }\r\n                // On the server, construct the deltalog.\r\n                state = initializeDeltalog(state, action, move);\r\n                // Allow the flow reducer to process any triggers that happen after moves.\r\n                state = game.flow.processMove(state, action.payload);\r\n                let stateWithError;\r\n                [state, stateWithError] = flushAndValidatePlugins(state, oldState, {\r\n                    game,\r\n                });\r\n                if (stateWithError)\r\n                    return stateWithError;\r\n                // Update undo / redo state.\r\n                state = updateUndoRedoState(state, { game, action });\r\n                return {\r\n                    ...state,\r\n                    _stateID: state._stateID + 1,\r\n                };\r\n            }\r\n            case RESET:\r\n            case UPDATE:\r\n            case SYNC: {\r\n                return action.state;\r\n            }\r\n            case UNDO: {\r\n                state = { ...state, deltalog: [] };\r\n                if (game.disableUndo) {\r\n                    error('Undo is not enabled');\r\n                    return WithError(state, ActionErrorType.ActionDisabled);\r\n                }\r\n                const { G, ctx, _undo, _redo, _stateID } = state;\r\n                if (_undo.length < 2) {\r\n                    error(`No moves to undo`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                const last = _undo[_undo.length - 1];\r\n                const restore = _undo[_undo.length - 2];\r\n                // Only allow players to undo their own moves.\r\n                if (actionHasPlayerID(action) &&\r\n                    action.payload.playerID !== last.playerID) {\r\n                    error(`Cannot undo other players' moves`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                // If undoing a move, check it is undoable.\r\n                if (last.moveType) {\r\n                    const lastMove = game.flow.getMove(restore.ctx, last.moveType, last.playerID);\r\n                    if (!CanUndoMove(G, ctx, lastMove)) {\r\n                        error(`Move cannot be undone`);\r\n                        return WithError(state, ActionErrorType.ActionInvalid);\r\n                    }\r\n                }\r\n                state = initializeDeltalog(state, action);\r\n                return {\r\n                    ...state,\r\n                    G: restore.G,\r\n                    ctx: restore.ctx,\r\n                    plugins: restore.plugins,\r\n                    _stateID: _stateID + 1,\r\n                    _undo: _undo.slice(0, -1),\r\n                    _redo: [last, ..._redo],\r\n                };\r\n            }\r\n            case REDO: {\r\n                state = { ...state, deltalog: [] };\r\n                if (game.disableUndo) {\r\n                    error('Redo is not enabled');\r\n                    return WithError(state, ActionErrorType.ActionDisabled);\r\n                }\r\n                const { _undo, _redo, _stateID } = state;\r\n                if (_redo.length === 0) {\r\n                    error(`No moves to redo`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                const first = _redo[0];\r\n                // Only allow players to redo their own undos.\r\n                if (actionHasPlayerID(action) &&\r\n                    action.payload.playerID !== first.playerID) {\r\n                    error(`Cannot redo other players' moves`);\r\n                    return WithError(state, ActionErrorType.ActionInvalid);\r\n                }\r\n                state = initializeDeltalog(state, action);\r\n                return {\r\n                    ...state,\r\n                    G: first.G,\r\n                    ctx: first.ctx,\r\n                    plugins: first.plugins,\r\n                    _stateID: _stateID + 1,\r\n                    _undo: [..._undo, first],\r\n                    _redo: _redo.slice(1),\r\n                };\r\n            }\r\n            case PLUGIN: {\r\n                // TODO(#723): Expose error semantics to plugin processing.\r\n                return ProcessAction(state, action, { game });\r\n            }\r\n            case PATCH: {\r\n                const oldState = state;\r\n                const newState = JSON.parse(JSON.stringify(oldState));\r\n                const patchError = applyPatch(newState, action.patch);\r\n                const hasError = patchError.some((entry) => entry !== null);\r\n                if (hasError) {\r\n                    error(`Patch ${JSON.stringify(action.patch)} apply failed`);\r\n                    return WithError(oldState, UpdateErrorType.PatchFailed, patchError);\r\n                }\r\n                else {\r\n                    return newState;\r\n                }\r\n            }\r\n            default: {\r\n                return state;\r\n            }\r\n        }\r\n    };\r\n}\n\nexport { CreateGameReducer as C, IsLongFormMove as I, ProcessGameConfig as P, TransientHandlingMiddleware as T };\n"]},"metadata":{},"sourceType":"module"}