{"ast":null,"code":"import { B as makeMove, g as gameEvent } from './turn-order-0b7dce3d.js';\nimport { a as alea } from './plugin-random-087f861e.js';\nimport { C as CreateGameReducer } from './reducer-07c7b307.js';\nimport 'setimmediate';\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Base class that bots can extend.\r\n */\n\nclass Bot {\n  constructor(_ref) {\n    let {\n      enumerate,\n      seed\n    } = _ref;\n    this.enumerateFn = enumerate;\n    this.seed = seed;\n    this.iterationCounter = 0;\n    this._opts = {};\n  }\n\n  addOpt(_ref2) {\n    let {\n      key,\n      range,\n      initial\n    } = _ref2;\n    this._opts[key] = {\n      range,\n      value: initial\n    };\n  }\n\n  getOpt(key) {\n    return this._opts[key].value;\n  }\n\n  setOpt(key, value) {\n    if (key in this._opts) {\n      this._opts[key].value = value;\n    }\n  }\n\n  opts() {\n    return this._opts;\n  }\n\n  enumerate(G, ctx, playerID) {\n    const actions = this.enumerateFn(G, ctx, playerID);\n    return actions.map(a => {\n      if ('payload' in a) {\n        return a;\n      }\n\n      if ('move' in a) {\n        return makeMove(a.move, a.args, playerID);\n      }\n\n      if ('event' in a) {\n        return gameEvent(a.event, a.args, playerID);\n      }\n    });\n  }\n\n  random(arg) {\n    let number;\n\n    if (this.seed !== undefined) {\n      const seed = this.prngstate ? '' : this.seed;\n      const rand = alea(seed, this.prngstate);\n      number = rand();\n      this.prngstate = rand.state();\n    } else {\n      number = Math.random();\n    }\n\n    if (arg) {\n      if (Array.isArray(arg)) {\n        const id = Math.floor(number * arg.length);\n        return arg[id];\n      } else {\n        return Math.floor(number * arg);\n      }\n    }\n\n    return number;\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * The number of iterations to run before yielding to\r\n * the JS event loop (in async mode).\r\n */\n\n\nconst CHUNK_SIZE = 25;\n/**\r\n * Bot that uses Monte-Carlo Tree Search to find promising moves.\r\n */\n\nclass MCTSBot extends Bot {\n  constructor(_ref3) {\n    let {\n      enumerate,\n      seed,\n      objectives,\n      game,\n      iterations,\n      playoutDepth,\n      iterationCallback\n    } = _ref3;\n    super({\n      enumerate,\n      seed\n    });\n\n    if (objectives === undefined) {\n      objectives = () => ({});\n    }\n\n    this.objectives = objectives;\n\n    this.iterationCallback = iterationCallback || (() => {});\n\n    this.reducer = CreateGameReducer({\n      game\n    });\n    this.iterations = iterations;\n    this.playoutDepth = playoutDepth;\n    this.addOpt({\n      key: 'async',\n      initial: false\n    });\n    this.addOpt({\n      key: 'iterations',\n      initial: typeof iterations === 'number' ? iterations : 1000,\n      range: {\n        min: 1,\n        max: 2000\n      }\n    });\n    this.addOpt({\n      key: 'playoutDepth',\n      initial: typeof playoutDepth === 'number' ? playoutDepth : 50,\n      range: {\n        min: 1,\n        max: 100\n      }\n    });\n  }\n\n  createNode(_ref4) {\n    let {\n      state,\n      parentAction,\n      parent,\n      playerID\n    } = _ref4;\n    const {\n      G,\n      ctx\n    } = state;\n    let actions = [];\n    let objectives = [];\n\n    if (playerID !== undefined) {\n      actions = this.enumerate(G, ctx, playerID);\n      objectives = this.objectives(G, ctx, playerID);\n    } else if (ctx.activePlayers) {\n      for (const playerID in ctx.activePlayers) {\n        actions.push(...this.enumerate(G, ctx, playerID));\n        objectives.push(this.objectives(G, ctx, playerID));\n      }\n    } else {\n      actions = this.enumerate(G, ctx, ctx.currentPlayer);\n      objectives = this.objectives(G, ctx, ctx.currentPlayer);\n    }\n\n    return {\n      state,\n      parent,\n      parentAction,\n      actions,\n      objectives,\n      children: [],\n      visits: 0,\n      value: 0\n    };\n  }\n\n  select(node) {\n    // This node has unvisited children.\n    if (node.actions.length > 0) {\n      return node;\n    } // This is a terminal node.\n\n\n    if (node.children.length === 0) {\n      return node;\n    }\n\n    let selectedChild = null;\n    let best = 0;\n\n    for (const child of node.children) {\n      const childVisits = child.visits + Number.EPSILON;\n      const uct = child.value / childVisits + Math.sqrt(2 * Math.log(node.visits) / childVisits);\n\n      if (selectedChild == null || uct > best) {\n        best = uct;\n        selectedChild = child;\n      }\n    }\n\n    return this.select(selectedChild);\n  }\n\n  expand(node) {\n    const actions = node.actions;\n\n    if (actions.length === 0 || node.state.ctx.gameover !== undefined) {\n      return node;\n    }\n\n    const id = this.random(actions.length);\n    const action = actions[id];\n    node.actions.splice(id, 1);\n    const childState = this.reducer(node.state, action);\n    const childNode = this.createNode({\n      state: childState,\n      parentAction: action,\n      parent: node\n    });\n    node.children.push(childNode);\n    return childNode;\n  }\n\n  playout(_ref5) {\n    let {\n      state\n    } = _ref5;\n    let playoutDepth = this.getOpt('playoutDepth');\n\n    if (typeof this.playoutDepth === 'function') {\n      playoutDepth = this.playoutDepth(state.G, state.ctx);\n    }\n\n    for (let i = 0; i < playoutDepth && state.ctx.gameover === undefined; i++) {\n      const {\n        G,\n        ctx\n      } = state;\n      let playerID = ctx.currentPlayer;\n\n      if (ctx.activePlayers) {\n        playerID = Object.keys(ctx.activePlayers)[0];\n      }\n\n      const moves = this.enumerate(G, ctx, playerID); // Check if any objectives are met.\n\n      const objectives = this.objectives(G, ctx, playerID);\n      const score = Object.keys(objectives).reduce((score, key) => {\n        const objective = objectives[key];\n\n        if (objective.checker(G, ctx)) {\n          return score + objective.weight;\n        }\n\n        return score;\n      }, 0); // If so, stop and return the score.\n\n      if (score > 0) {\n        return {\n          score\n        };\n      }\n\n      if (!moves || moves.length === 0) {\n        return undefined;\n      }\n\n      const id = this.random(moves.length);\n      const childState = this.reducer(state, moves[id]);\n      state = childState;\n    }\n\n    return state.ctx.gameover;\n  }\n\n  backpropagate(node) {\n    let result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    node.visits++;\n\n    if (result.score !== undefined) {\n      node.value += result.score;\n    }\n\n    if (result.draw === true) {\n      node.value += 0.5;\n    }\n\n    if (node.parentAction && result.winner === node.parentAction.payload.playerID) {\n      node.value++;\n    }\n\n    if (node.parent) {\n      this.backpropagate(node.parent, result);\n    }\n  }\n\n  play(state, playerID) {\n    const root = this.createNode({\n      state,\n      playerID\n    });\n    let numIterations = this.getOpt('iterations');\n\n    if (typeof this.iterations === 'function') {\n      numIterations = this.iterations(state.G, state.ctx);\n    }\n\n    const getResult = () => {\n      let selectedChild = null;\n\n      for (const child of root.children) {\n        if (selectedChild == null || child.visits > selectedChild.visits) {\n          selectedChild = child;\n        }\n      }\n\n      const action = selectedChild && selectedChild.parentAction;\n      const metadata = root;\n      return {\n        action,\n        metadata\n      };\n    };\n\n    return new Promise(resolve => {\n      const iteration = () => {\n        for (let i = 0; i < CHUNK_SIZE && this.iterationCounter < numIterations; i++) {\n          const leaf = this.select(root);\n          const child = this.expand(leaf);\n          const result = this.playout(child);\n          this.backpropagate(child, result);\n          this.iterationCounter++;\n        }\n\n        this.iterationCallback({\n          iterationCounter: this.iterationCounter,\n          numIterations,\n          metadata: root\n        });\n      };\n\n      this.iterationCounter = 0;\n\n      if (this.getOpt('async')) {\n        const asyncIteration = () => {\n          if (this.iterationCounter < numIterations) {\n            iteration();\n            setImmediate(asyncIteration);\n          } else {\n            resolve(getResult());\n          }\n        };\n\n        asyncIteration();\n      } else {\n        while (this.iterationCounter < numIterations) {\n          iteration();\n        }\n\n        resolve(getResult());\n      }\n    });\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Bot that picks a move at random.\r\n */\n\n\nclass RandomBot extends Bot {\n  play(_ref6, playerID) {\n    let {\n      G,\n      ctx\n    } = _ref6;\n    const moves = this.enumerate(G, ctx, playerID);\n    return Promise.resolve({\n      action: this.random(moves)\n    });\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Make a single move on the client with a bot.\r\n *\r\n * @param {...object} client - The game client.\r\n * @param {...object} bot - The bot.\r\n */\n\n\nasync function Step(client, bot) {\n  const state = client.store.getState();\n  let playerID = state.ctx.currentPlayer;\n\n  if (state.ctx.activePlayers) {\n    playerID = Object.keys(state.ctx.activePlayers)[0];\n  }\n\n  const {\n    action,\n    metadata\n  } = await bot.play(state, playerID);\n\n  if (action) {\n    const a = { ...action,\n      payload: { ...action.payload,\n        metadata\n      }\n    };\n    client.store.dispatch(a);\n    return a;\n  }\n}\n/**\r\n * Simulates the game till the end or a max depth.\r\n *\r\n * @param {...object} game - The game object.\r\n * @param {...object} bots - An array of bots.\r\n * @param {...object} state - The game state to start from.\r\n */\n\n\nasync function Simulate(_ref7) {\n  let {\n    game,\n    bots,\n    state,\n    depth\n  } = _ref7;\n  if (depth === undefined) depth = 10000;\n  const reducer = CreateGameReducer({\n    game\n  });\n  let metadata = null;\n  let iter = 0;\n\n  while (state.ctx.gameover === undefined && iter < depth) {\n    let playerID = state.ctx.currentPlayer;\n\n    if (state.ctx.activePlayers) {\n      playerID = Object.keys(state.ctx.activePlayers)[0];\n    }\n\n    const bot = bots instanceof Bot ? bots : bots[playerID];\n    const t = await bot.play(state, playerID);\n\n    if (!t.action) {\n      break;\n    }\n\n    metadata = t.metadata;\n    state = reducer(state, t.action);\n    iter++;\n  }\n\n  return {\n    state,\n    metadata\n  };\n}\n\nexport { Bot as B, MCTSBot as M, RandomBot as R, Step as S, Simulate as a };","map":{"version":3,"sources":["D:/CS161_Breadsticks/front/node_modules/boardgame.io/dist/esm/ai-3099ce9a.js"],"names":["B","makeMove","g","gameEvent","a","alea","C","CreateGameReducer","Bot","constructor","enumerate","seed","enumerateFn","iterationCounter","_opts","addOpt","key","range","initial","value","getOpt","setOpt","opts","G","ctx","playerID","actions","map","move","args","event","random","arg","number","undefined","prngstate","rand","state","Math","Array","isArray","id","floor","length","CHUNK_SIZE","MCTSBot","objectives","game","iterations","playoutDepth","iterationCallback","reducer","min","max","createNode","parentAction","parent","activePlayers","push","currentPlayer","children","visits","select","node","selectedChild","best","child","childVisits","Number","EPSILON","uct","sqrt","log","expand","gameover","action","splice","childState","childNode","playout","i","Object","keys","moves","score","reduce","objective","checker","weight","backpropagate","result","draw","winner","payload","play","root","numIterations","getResult","metadata","Promise","resolve","iteration","leaf","asyncIteration","setImmediate","RandomBot","Step","client","bot","store","getState","dispatch","Simulate","bots","depth","iter","t","M","R","S"],"mappings":"AAAA,SAASA,CAAC,IAAIC,QAAd,EAAwBC,CAAC,IAAIC,SAA7B,QAA8C,0BAA9C;AACA,SAASC,CAAC,IAAIC,IAAd,QAA0B,6BAA1B;AACA,SAASC,CAAC,IAAIC,iBAAd,QAAuC,uBAAvC;AACA,OAAO,cAAP;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;AACA,MAAMC,GAAN,CAAU;AACNC,EAAAA,WAAW,OAAuB;AAAA,QAAtB;AAAEC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAAsB;AAC9B,SAAKC,WAAL,GAAmBF,SAAnB;AACA,SAAKC,IAAL,GAAYA,IAAZ;AACA,SAAKE,gBAAL,GAAwB,CAAxB;AACA,SAAKC,KAAL,GAAa,EAAb;AACH;;AACDC,EAAAA,MAAM,QAA2B;AAAA,QAA1B;AAAEC,MAAAA,GAAF;AAAOC,MAAAA,KAAP;AAAcC,MAAAA;AAAd,KAA0B;AAC7B,SAAKJ,KAAL,CAAWE,GAAX,IAAkB;AACdC,MAAAA,KADc;AAEdE,MAAAA,KAAK,EAAED;AAFO,KAAlB;AAIH;;AACDE,EAAAA,MAAM,CAACJ,GAAD,EAAM;AACR,WAAO,KAAKF,KAAL,CAAWE,GAAX,EAAgBG,KAAvB;AACH;;AACDE,EAAAA,MAAM,CAACL,GAAD,EAAMG,KAAN,EAAa;AACf,QAAIH,GAAG,IAAI,KAAKF,KAAhB,EAAuB;AACnB,WAAKA,KAAL,CAAWE,GAAX,EAAgBG,KAAhB,GAAwBA,KAAxB;AACH;AACJ;;AACDG,EAAAA,IAAI,GAAG;AACH,WAAO,KAAKR,KAAZ;AACH;;AACDJ,EAAAA,SAAS,CAACa,CAAD,EAAIC,GAAJ,EAASC,QAAT,EAAmB;AACxB,UAAMC,OAAO,GAAG,KAAKd,WAAL,CAAiBW,CAAjB,EAAoBC,GAApB,EAAyBC,QAAzB,CAAhB;AACA,WAAOC,OAAO,CAACC,GAAR,CAAavB,CAAD,IAAO;AACtB,UAAI,aAAaA,CAAjB,EAAoB;AAChB,eAAOA,CAAP;AACH;;AACD,UAAI,UAAUA,CAAd,EAAiB;AACb,eAAOH,QAAQ,CAACG,CAAC,CAACwB,IAAH,EAASxB,CAAC,CAACyB,IAAX,EAAiBJ,QAAjB,CAAf;AACH;;AACD,UAAI,WAAWrB,CAAf,EAAkB;AACd,eAAOD,SAAS,CAACC,CAAC,CAAC0B,KAAH,EAAU1B,CAAC,CAACyB,IAAZ,EAAkBJ,QAAlB,CAAhB;AACH;AACJ,KAVM,CAAP;AAWH;;AACDM,EAAAA,MAAM,CAACC,GAAD,EAAM;AACR,QAAIC,MAAJ;;AACA,QAAI,KAAKtB,IAAL,KAAcuB,SAAlB,EAA6B;AACzB,YAAMvB,IAAI,GAAG,KAAKwB,SAAL,GAAiB,EAAjB,GAAsB,KAAKxB,IAAxC;AACA,YAAMyB,IAAI,GAAG/B,IAAI,CAACM,IAAD,EAAO,KAAKwB,SAAZ,CAAjB;AACAF,MAAAA,MAAM,GAAGG,IAAI,EAAb;AACA,WAAKD,SAAL,GAAiBC,IAAI,CAACC,KAAL,EAAjB;AACH,KALD,MAMK;AACDJ,MAAAA,MAAM,GAAGK,IAAI,CAACP,MAAL,EAAT;AACH;;AACD,QAAIC,GAAJ,EAAS;AACL,UAAIO,KAAK,CAACC,OAAN,CAAcR,GAAd,CAAJ,EAAwB;AACpB,cAAMS,EAAE,GAAGH,IAAI,CAACI,KAAL,CAAWT,MAAM,GAAGD,GAAG,CAACW,MAAxB,CAAX;AACA,eAAOX,GAAG,CAACS,EAAD,CAAV;AACH,OAHD,MAIK;AACD,eAAOH,IAAI,CAACI,KAAL,CAAWT,MAAM,GAAGD,GAApB,CAAP;AACH;AACJ;;AACD,WAAOC,MAAP;AACH;;AA3DK;AA8DV;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;;AACA,MAAMW,UAAU,GAAG,EAAnB;AACA;AACA;AACA;;AACA,MAAMC,OAAN,SAAsBrC,GAAtB,CAA0B;AACtBC,EAAAA,WAAW,QAAsF;AAAA,QAArF;AAAEC,MAAAA,SAAF;AAAaC,MAAAA,IAAb;AAAmBmC,MAAAA,UAAnB;AAA+BC,MAAAA,IAA/B;AAAqCC,MAAAA,UAArC;AAAiDC,MAAAA,YAAjD;AAA+DC,MAAAA;AAA/D,KAAqF;AAC7F,UAAM;AAAExC,MAAAA,SAAF;AAAaC,MAAAA;AAAb,KAAN;;AACA,QAAImC,UAAU,KAAKZ,SAAnB,EAA8B;AAC1BY,MAAAA,UAAU,GAAG,OAAO,EAAP,CAAb;AACH;;AACD,SAAKA,UAAL,GAAkBA,UAAlB;;AACA,SAAKI,iBAAL,GAAyBA,iBAAiB,KAAK,MAAM,CAAG,CAAd,CAA1C;;AACA,SAAKC,OAAL,GAAe5C,iBAAiB,CAAC;AAAEwC,MAAAA;AAAF,KAAD,CAAhC;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACA,SAAKC,YAAL,GAAoBA,YAApB;AACA,SAAKlC,MAAL,CAAY;AACRC,MAAAA,GAAG,EAAE,OADG;AAERE,MAAAA,OAAO,EAAE;AAFD,KAAZ;AAIA,SAAKH,MAAL,CAAY;AACRC,MAAAA,GAAG,EAAE,YADG;AAERE,MAAAA,OAAO,EAAE,OAAO8B,UAAP,KAAsB,QAAtB,GAAiCA,UAAjC,GAA8C,IAF/C;AAGR/B,MAAAA,KAAK,EAAE;AAAEmC,QAAAA,GAAG,EAAE,CAAP;AAAUC,QAAAA,GAAG,EAAE;AAAf;AAHC,KAAZ;AAKA,SAAKtC,MAAL,CAAY;AACRC,MAAAA,GAAG,EAAE,cADG;AAERE,MAAAA,OAAO,EAAE,OAAO+B,YAAP,KAAwB,QAAxB,GAAmCA,YAAnC,GAAkD,EAFnD;AAGRhC,MAAAA,KAAK,EAAE;AAAEmC,QAAAA,GAAG,EAAE,CAAP;AAAUC,QAAAA,GAAG,EAAE;AAAf;AAHC,KAAZ;AAKH;;AACDC,EAAAA,UAAU,QAA6C;AAAA,QAA5C;AAAEjB,MAAAA,KAAF;AAASkB,MAAAA,YAAT;AAAuBC,MAAAA,MAAvB;AAA+B/B,MAAAA;AAA/B,KAA4C;AACnD,UAAM;AAAEF,MAAAA,CAAF;AAAKC,MAAAA;AAAL,QAAaa,KAAnB;AACA,QAAIX,OAAO,GAAG,EAAd;AACA,QAAIoB,UAAU,GAAG,EAAjB;;AACA,QAAIrB,QAAQ,KAAKS,SAAjB,EAA4B;AACxBR,MAAAA,OAAO,GAAG,KAAKhB,SAAL,CAAea,CAAf,EAAkBC,GAAlB,EAAuBC,QAAvB,CAAV;AACAqB,MAAAA,UAAU,GAAG,KAAKA,UAAL,CAAgBvB,CAAhB,EAAmBC,GAAnB,EAAwBC,QAAxB,CAAb;AACH,KAHD,MAIK,IAAID,GAAG,CAACiC,aAAR,EAAuB;AACxB,WAAK,MAAMhC,QAAX,IAAuBD,GAAG,CAACiC,aAA3B,EAA0C;AACtC/B,QAAAA,OAAO,CAACgC,IAAR,CAAa,GAAG,KAAKhD,SAAL,CAAea,CAAf,EAAkBC,GAAlB,EAAuBC,QAAvB,CAAhB;AACAqB,QAAAA,UAAU,CAACY,IAAX,CAAgB,KAAKZ,UAAL,CAAgBvB,CAAhB,EAAmBC,GAAnB,EAAwBC,QAAxB,CAAhB;AACH;AACJ,KALI,MAMA;AACDC,MAAAA,OAAO,GAAG,KAAKhB,SAAL,CAAea,CAAf,EAAkBC,GAAlB,EAAuBA,GAAG,CAACmC,aAA3B,CAAV;AACAb,MAAAA,UAAU,GAAG,KAAKA,UAAL,CAAgBvB,CAAhB,EAAmBC,GAAnB,EAAwBA,GAAG,CAACmC,aAA5B,CAAb;AACH;;AACD,WAAO;AACHtB,MAAAA,KADG;AAEHmB,MAAAA,MAFG;AAGHD,MAAAA,YAHG;AAIH7B,MAAAA,OAJG;AAKHoB,MAAAA,UALG;AAMHc,MAAAA,QAAQ,EAAE,EANP;AAOHC,MAAAA,MAAM,EAAE,CAPL;AAQH1C,MAAAA,KAAK,EAAE;AARJ,KAAP;AAUH;;AACD2C,EAAAA,MAAM,CAACC,IAAD,EAAO;AACT;AACA,QAAIA,IAAI,CAACrC,OAAL,CAAaiB,MAAb,GAAsB,CAA1B,EAA6B;AACzB,aAAOoB,IAAP;AACH,KAJQ,CAKT;;;AACA,QAAIA,IAAI,CAACH,QAAL,CAAcjB,MAAd,KAAyB,CAA7B,EAAgC;AAC5B,aAAOoB,IAAP;AACH;;AACD,QAAIC,aAAa,GAAG,IAApB;AACA,QAAIC,IAAI,GAAG,CAAX;;AACA,SAAK,MAAMC,KAAX,IAAoBH,IAAI,CAACH,QAAzB,EAAmC;AAC/B,YAAMO,WAAW,GAAGD,KAAK,CAACL,MAAN,GAAeO,MAAM,CAACC,OAA1C;AACA,YAAMC,GAAG,GAAGJ,KAAK,CAAC/C,KAAN,GAAcgD,WAAd,GACR7B,IAAI,CAACiC,IAAL,CAAW,IAAIjC,IAAI,CAACkC,GAAL,CAAST,IAAI,CAACF,MAAd,CAAL,GAA8BM,WAAxC,CADJ;;AAEA,UAAIH,aAAa,IAAI,IAAjB,IAAyBM,GAAG,GAAGL,IAAnC,EAAyC;AACrCA,QAAAA,IAAI,GAAGK,GAAP;AACAN,QAAAA,aAAa,GAAGE,KAAhB;AACH;AACJ;;AACD,WAAO,KAAKJ,MAAL,CAAYE,aAAZ,CAAP;AACH;;AACDS,EAAAA,MAAM,CAACV,IAAD,EAAO;AACT,UAAMrC,OAAO,GAAGqC,IAAI,CAACrC,OAArB;;AACA,QAAIA,OAAO,CAACiB,MAAR,KAAmB,CAAnB,IAAwBoB,IAAI,CAAC1B,KAAL,CAAWb,GAAX,CAAekD,QAAf,KAA4BxC,SAAxD,EAAmE;AAC/D,aAAO6B,IAAP;AACH;;AACD,UAAMtB,EAAE,GAAG,KAAKV,MAAL,CAAYL,OAAO,CAACiB,MAApB,CAAX;AACA,UAAMgC,MAAM,GAAGjD,OAAO,CAACe,EAAD,CAAtB;AACAsB,IAAAA,IAAI,CAACrC,OAAL,CAAakD,MAAb,CAAoBnC,EAApB,EAAwB,CAAxB;AACA,UAAMoC,UAAU,GAAG,KAAK1B,OAAL,CAAaY,IAAI,CAAC1B,KAAlB,EAAyBsC,MAAzB,CAAnB;AACA,UAAMG,SAAS,GAAG,KAAKxB,UAAL,CAAgB;AAC9BjB,MAAAA,KAAK,EAAEwC,UADuB;AAE9BtB,MAAAA,YAAY,EAAEoB,MAFgB;AAG9BnB,MAAAA,MAAM,EAAEO;AAHsB,KAAhB,CAAlB;AAKAA,IAAAA,IAAI,CAACH,QAAL,CAAcF,IAAd,CAAmBoB,SAAnB;AACA,WAAOA,SAAP;AACH;;AACDC,EAAAA,OAAO,QAAY;AAAA,QAAX;AAAE1C,MAAAA;AAAF,KAAW;AACf,QAAIY,YAAY,GAAG,KAAK7B,MAAL,CAAY,cAAZ,CAAnB;;AACA,QAAI,OAAO,KAAK6B,YAAZ,KAA6B,UAAjC,EAA6C;AACzCA,MAAAA,YAAY,GAAG,KAAKA,YAAL,CAAkBZ,KAAK,CAACd,CAAxB,EAA2Bc,KAAK,CAACb,GAAjC,CAAf;AACH;;AACD,SAAK,IAAIwD,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG/B,YAAJ,IAAoBZ,KAAK,CAACb,GAAN,CAAUkD,QAAV,KAAuBxC,SAA3D,EAAsE8C,CAAC,EAAvE,EAA2E;AACvE,YAAM;AAAEzD,QAAAA,CAAF;AAAKC,QAAAA;AAAL,UAAaa,KAAnB;AACA,UAAIZ,QAAQ,GAAGD,GAAG,CAACmC,aAAnB;;AACA,UAAInC,GAAG,CAACiC,aAAR,EAAuB;AACnBhC,QAAAA,QAAQ,GAAGwD,MAAM,CAACC,IAAP,CAAY1D,GAAG,CAACiC,aAAhB,EAA+B,CAA/B,CAAX;AACH;;AACD,YAAM0B,KAAK,GAAG,KAAKzE,SAAL,CAAea,CAAf,EAAkBC,GAAlB,EAAuBC,QAAvB,CAAd,CANuE,CAOvE;;AACA,YAAMqB,UAAU,GAAG,KAAKA,UAAL,CAAgBvB,CAAhB,EAAmBC,GAAnB,EAAwBC,QAAxB,CAAnB;AACA,YAAM2D,KAAK,GAAGH,MAAM,CAACC,IAAP,CAAYpC,UAAZ,EAAwBuC,MAAxB,CAA+B,CAACD,KAAD,EAAQpE,GAAR,KAAgB;AACzD,cAAMsE,SAAS,GAAGxC,UAAU,CAAC9B,GAAD,CAA5B;;AACA,YAAIsE,SAAS,CAACC,OAAV,CAAkBhE,CAAlB,EAAqBC,GAArB,CAAJ,EAA+B;AAC3B,iBAAO4D,KAAK,GAAGE,SAAS,CAACE,MAAzB;AACH;;AACD,eAAOJ,KAAP;AACH,OANa,EAMX,CANW,CAAd,CATuE,CAgBvE;;AACA,UAAIA,KAAK,GAAG,CAAZ,EAAe;AACX,eAAO;AAAEA,UAAAA;AAAF,SAAP;AACH;;AACD,UAAI,CAACD,KAAD,IAAUA,KAAK,CAACxC,MAAN,KAAiB,CAA/B,EAAkC;AAC9B,eAAOT,SAAP;AACH;;AACD,YAAMO,EAAE,GAAG,KAAKV,MAAL,CAAYoD,KAAK,CAACxC,MAAlB,CAAX;AACA,YAAMkC,UAAU,GAAG,KAAK1B,OAAL,CAAad,KAAb,EAAoB8C,KAAK,CAAC1C,EAAD,CAAzB,CAAnB;AACAJ,MAAAA,KAAK,GAAGwC,UAAR;AACH;;AACD,WAAOxC,KAAK,CAACb,GAAN,CAAUkD,QAAjB;AACH;;AACDe,EAAAA,aAAa,CAAC1B,IAAD,EAAoB;AAAA,QAAb2B,MAAa,uEAAJ,EAAI;AAC7B3B,IAAAA,IAAI,CAACF,MAAL;;AACA,QAAI6B,MAAM,CAACN,KAAP,KAAiBlD,SAArB,EAAgC;AAC5B6B,MAAAA,IAAI,CAAC5C,KAAL,IAAcuE,MAAM,CAACN,KAArB;AACH;;AACD,QAAIM,MAAM,CAACC,IAAP,KAAgB,IAApB,EAA0B;AACtB5B,MAAAA,IAAI,CAAC5C,KAAL,IAAc,GAAd;AACH;;AACD,QAAI4C,IAAI,CAACR,YAAL,IACAmC,MAAM,CAACE,MAAP,KAAkB7B,IAAI,CAACR,YAAL,CAAkBsC,OAAlB,CAA0BpE,QADhD,EAC0D;AACtDsC,MAAAA,IAAI,CAAC5C,KAAL;AACH;;AACD,QAAI4C,IAAI,CAACP,MAAT,EAAiB;AACb,WAAKiC,aAAL,CAAmB1B,IAAI,CAACP,MAAxB,EAAgCkC,MAAhC;AACH;AACJ;;AACDI,EAAAA,IAAI,CAACzD,KAAD,EAAQZ,QAAR,EAAkB;AAClB,UAAMsE,IAAI,GAAG,KAAKzC,UAAL,CAAgB;AAAEjB,MAAAA,KAAF;AAASZ,MAAAA;AAAT,KAAhB,CAAb;AACA,QAAIuE,aAAa,GAAG,KAAK5E,MAAL,CAAY,YAAZ,CAApB;;AACA,QAAI,OAAO,KAAK4B,UAAZ,KAA2B,UAA/B,EAA2C;AACvCgD,MAAAA,aAAa,GAAG,KAAKhD,UAAL,CAAgBX,KAAK,CAACd,CAAtB,EAAyBc,KAAK,CAACb,GAA/B,CAAhB;AACH;;AACD,UAAMyE,SAAS,GAAG,MAAM;AACpB,UAAIjC,aAAa,GAAG,IAApB;;AACA,WAAK,MAAME,KAAX,IAAoB6B,IAAI,CAACnC,QAAzB,EAAmC;AAC/B,YAAII,aAAa,IAAI,IAAjB,IAAyBE,KAAK,CAACL,MAAN,GAAeG,aAAa,CAACH,MAA1D,EAAkE;AAC9DG,UAAAA,aAAa,GAAGE,KAAhB;AACH;AACJ;;AACD,YAAMS,MAAM,GAAGX,aAAa,IAAIA,aAAa,CAACT,YAA9C;AACA,YAAM2C,QAAQ,GAAGH,IAAjB;AACA,aAAO;AAAEpB,QAAAA,MAAF;AAAUuB,QAAAA;AAAV,OAAP;AACH,KAVD;;AAWA,WAAO,IAAIC,OAAJ,CAAaC,OAAD,IAAa;AAC5B,YAAMC,SAAS,GAAG,MAAM;AACpB,aAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGpC,UAAJ,IAAkB,KAAK/B,gBAAL,GAAwBmF,aAA1D,EAAyEhB,CAAC,EAA1E,EAA8E;AAC1E,gBAAMsB,IAAI,GAAG,KAAKxC,MAAL,CAAYiC,IAAZ,CAAb;AACA,gBAAM7B,KAAK,GAAG,KAAKO,MAAL,CAAY6B,IAAZ,CAAd;AACA,gBAAMZ,MAAM,GAAG,KAAKX,OAAL,CAAab,KAAb,CAAf;AACA,eAAKuB,aAAL,CAAmBvB,KAAnB,EAA0BwB,MAA1B;AACA,eAAK7E,gBAAL;AACH;;AACD,aAAKqC,iBAAL,CAAuB;AACnBrC,UAAAA,gBAAgB,EAAE,KAAKA,gBADJ;AAEnBmF,UAAAA,aAFmB;AAGnBE,UAAAA,QAAQ,EAAEH;AAHS,SAAvB;AAKH,OAbD;;AAcA,WAAKlF,gBAAL,GAAwB,CAAxB;;AACA,UAAI,KAAKO,MAAL,CAAY,OAAZ,CAAJ,EAA0B;AACtB,cAAMmF,cAAc,GAAG,MAAM;AACzB,cAAI,KAAK1F,gBAAL,GAAwBmF,aAA5B,EAA2C;AACvCK,YAAAA,SAAS;AACTG,YAAAA,YAAY,CAACD,cAAD,CAAZ;AACH,WAHD,MAIK;AACDH,YAAAA,OAAO,CAACH,SAAS,EAAV,CAAP;AACH;AACJ,SARD;;AASAM,QAAAA,cAAc;AACjB,OAXD,MAYK;AACD,eAAO,KAAK1F,gBAAL,GAAwBmF,aAA/B,EAA8C;AAC1CK,UAAAA,SAAS;AACZ;;AACDD,QAAAA,OAAO,CAACH,SAAS,EAAV,CAAP;AACH;AACJ,KAlCM,CAAP;AAmCH;;AApMqB;AAuM1B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;;;AACA,MAAMQ,SAAN,SAAwBjG,GAAxB,CAA4B;AACxBsF,EAAAA,IAAI,QAAarE,QAAb,EAAuB;AAAA,QAAtB;AAAEF,MAAAA,CAAF;AAAKC,MAAAA;AAAL,KAAsB;AACvB,UAAM2D,KAAK,GAAG,KAAKzE,SAAL,CAAea,CAAf,EAAkBC,GAAlB,EAAuBC,QAAvB,CAAd;AACA,WAAO0E,OAAO,CAACC,OAAR,CAAgB;AAAEzB,MAAAA,MAAM,EAAE,KAAK5C,MAAL,CAAYoD,KAAZ;AAAV,KAAhB,CAAP;AACH;;AAJuB;AAO5B;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAeuB,IAAf,CAAoBC,MAApB,EAA4BC,GAA5B,EAAiC;AAC7B,QAAMvE,KAAK,GAAGsE,MAAM,CAACE,KAAP,CAAaC,QAAb,EAAd;AACA,MAAIrF,QAAQ,GAAGY,KAAK,CAACb,GAAN,CAAUmC,aAAzB;;AACA,MAAItB,KAAK,CAACb,GAAN,CAAUiC,aAAd,EAA6B;AACzBhC,IAAAA,QAAQ,GAAGwD,MAAM,CAACC,IAAP,CAAY7C,KAAK,CAACb,GAAN,CAAUiC,aAAtB,EAAqC,CAArC,CAAX;AACH;;AACD,QAAM;AAAEkB,IAAAA,MAAF;AAAUuB,IAAAA;AAAV,MAAuB,MAAMU,GAAG,CAACd,IAAJ,CAASzD,KAAT,EAAgBZ,QAAhB,CAAnC;;AACA,MAAIkD,MAAJ,EAAY;AACR,UAAMvE,CAAC,GAAG,EACN,GAAGuE,MADG;AAENkB,MAAAA,OAAO,EAAE,EACL,GAAGlB,MAAM,CAACkB,OADL;AAELK,QAAAA;AAFK;AAFH,KAAV;AAOAS,IAAAA,MAAM,CAACE,KAAP,CAAaE,QAAb,CAAsB3G,CAAtB;AACA,WAAOA,CAAP;AACH;AACJ;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,eAAe4G,QAAf,QAAuD;AAAA,MAA/B;AAAEjE,IAAAA,IAAF;AAAQkE,IAAAA,IAAR;AAAc5E,IAAAA,KAAd;AAAqB6E,IAAAA;AAArB,GAA+B;AACnD,MAAIA,KAAK,KAAKhF,SAAd,EACIgF,KAAK,GAAG,KAAR;AACJ,QAAM/D,OAAO,GAAG5C,iBAAiB,CAAC;AAAEwC,IAAAA;AAAF,GAAD,CAAjC;AACA,MAAImD,QAAQ,GAAG,IAAf;AACA,MAAIiB,IAAI,GAAG,CAAX;;AACA,SAAO9E,KAAK,CAACb,GAAN,CAAUkD,QAAV,KAAuBxC,SAAvB,IAAoCiF,IAAI,GAAGD,KAAlD,EAAyD;AACrD,QAAIzF,QAAQ,GAAGY,KAAK,CAACb,GAAN,CAAUmC,aAAzB;;AACA,QAAItB,KAAK,CAACb,GAAN,CAAUiC,aAAd,EAA6B;AACzBhC,MAAAA,QAAQ,GAAGwD,MAAM,CAACC,IAAP,CAAY7C,KAAK,CAACb,GAAN,CAAUiC,aAAtB,EAAqC,CAArC,CAAX;AACH;;AACD,UAAMmD,GAAG,GAAGK,IAAI,YAAYzG,GAAhB,GAAsByG,IAAtB,GAA6BA,IAAI,CAACxF,QAAD,CAA7C;AACA,UAAM2F,CAAC,GAAG,MAAMR,GAAG,CAACd,IAAJ,CAASzD,KAAT,EAAgBZ,QAAhB,CAAhB;;AACA,QAAI,CAAC2F,CAAC,CAACzC,MAAP,EAAe;AACX;AACH;;AACDuB,IAAAA,QAAQ,GAAGkB,CAAC,CAAClB,QAAb;AACA7D,IAAAA,KAAK,GAAGc,OAAO,CAACd,KAAD,EAAQ+E,CAAC,CAACzC,MAAV,CAAf;AACAwC,IAAAA,IAAI;AACP;;AACD,SAAO;AAAE9E,IAAAA,KAAF;AAAS6D,IAAAA;AAAT,GAAP;AACH;;AAED,SAAS1F,GAAG,IAAIR,CAAhB,EAAmB6C,OAAO,IAAIwE,CAA9B,EAAiCZ,SAAS,IAAIa,CAA9C,EAAiDZ,IAAI,IAAIa,CAAzD,EAA4DP,QAAQ,IAAI5G,CAAxE","sourcesContent":["import { B as makeMove, g as gameEvent } from './turn-order-0b7dce3d.js';\nimport { a as alea } from './plugin-random-087f861e.js';\nimport { C as CreateGameReducer } from './reducer-07c7b307.js';\nimport 'setimmediate';\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Base class that bots can extend.\r\n */\r\nclass Bot {\r\n    constructor({ enumerate, seed, }) {\r\n        this.enumerateFn = enumerate;\r\n        this.seed = seed;\r\n        this.iterationCounter = 0;\r\n        this._opts = {};\r\n    }\r\n    addOpt({ key, range, initial, }) {\r\n        this._opts[key] = {\r\n            range,\r\n            value: initial,\r\n        };\r\n    }\r\n    getOpt(key) {\r\n        return this._opts[key].value;\r\n    }\r\n    setOpt(key, value) {\r\n        if (key in this._opts) {\r\n            this._opts[key].value = value;\r\n        }\r\n    }\r\n    opts() {\r\n        return this._opts;\r\n    }\r\n    enumerate(G, ctx, playerID) {\r\n        const actions = this.enumerateFn(G, ctx, playerID);\r\n        return actions.map((a) => {\r\n            if ('payload' in a) {\r\n                return a;\r\n            }\r\n            if ('move' in a) {\r\n                return makeMove(a.move, a.args, playerID);\r\n            }\r\n            if ('event' in a) {\r\n                return gameEvent(a.event, a.args, playerID);\r\n            }\r\n        });\r\n    }\r\n    random(arg) {\r\n        let number;\r\n        if (this.seed !== undefined) {\r\n            const seed = this.prngstate ? '' : this.seed;\r\n            const rand = alea(seed, this.prngstate);\r\n            number = rand();\r\n            this.prngstate = rand.state();\r\n        }\r\n        else {\r\n            number = Math.random();\r\n        }\r\n        if (arg) {\r\n            if (Array.isArray(arg)) {\r\n                const id = Math.floor(number * arg.length);\r\n                return arg[id];\r\n            }\r\n            else {\r\n                return Math.floor(number * arg);\r\n            }\r\n        }\r\n        return number;\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * The number of iterations to run before yielding to\r\n * the JS event loop (in async mode).\r\n */\r\nconst CHUNK_SIZE = 25;\r\n/**\r\n * Bot that uses Monte-Carlo Tree Search to find promising moves.\r\n */\r\nclass MCTSBot extends Bot {\r\n    constructor({ enumerate, seed, objectives, game, iterations, playoutDepth, iterationCallback, }) {\r\n        super({ enumerate, seed });\r\n        if (objectives === undefined) {\r\n            objectives = () => ({});\r\n        }\r\n        this.objectives = objectives;\r\n        this.iterationCallback = iterationCallback || (() => { });\r\n        this.reducer = CreateGameReducer({ game });\r\n        this.iterations = iterations;\r\n        this.playoutDepth = playoutDepth;\r\n        this.addOpt({\r\n            key: 'async',\r\n            initial: false,\r\n        });\r\n        this.addOpt({\r\n            key: 'iterations',\r\n            initial: typeof iterations === 'number' ? iterations : 1000,\r\n            range: { min: 1, max: 2000 },\r\n        });\r\n        this.addOpt({\r\n            key: 'playoutDepth',\r\n            initial: typeof playoutDepth === 'number' ? playoutDepth : 50,\r\n            range: { min: 1, max: 100 },\r\n        });\r\n    }\r\n    createNode({ state, parentAction, parent, playerID, }) {\r\n        const { G, ctx } = state;\r\n        let actions = [];\r\n        let objectives = [];\r\n        if (playerID !== undefined) {\r\n            actions = this.enumerate(G, ctx, playerID);\r\n            objectives = this.objectives(G, ctx, playerID);\r\n        }\r\n        else if (ctx.activePlayers) {\r\n            for (const playerID in ctx.activePlayers) {\r\n                actions.push(...this.enumerate(G, ctx, playerID));\r\n                objectives.push(this.objectives(G, ctx, playerID));\r\n            }\r\n        }\r\n        else {\r\n            actions = this.enumerate(G, ctx, ctx.currentPlayer);\r\n            objectives = this.objectives(G, ctx, ctx.currentPlayer);\r\n        }\r\n        return {\r\n            state,\r\n            parent,\r\n            parentAction,\r\n            actions,\r\n            objectives,\r\n            children: [],\r\n            visits: 0,\r\n            value: 0,\r\n        };\r\n    }\r\n    select(node) {\r\n        // This node has unvisited children.\r\n        if (node.actions.length > 0) {\r\n            return node;\r\n        }\r\n        // This is a terminal node.\r\n        if (node.children.length === 0) {\r\n            return node;\r\n        }\r\n        let selectedChild = null;\r\n        let best = 0;\r\n        for (const child of node.children) {\r\n            const childVisits = child.visits + Number.EPSILON;\r\n            const uct = child.value / childVisits +\r\n                Math.sqrt((2 * Math.log(node.visits)) / childVisits);\r\n            if (selectedChild == null || uct > best) {\r\n                best = uct;\r\n                selectedChild = child;\r\n            }\r\n        }\r\n        return this.select(selectedChild);\r\n    }\r\n    expand(node) {\r\n        const actions = node.actions;\r\n        if (actions.length === 0 || node.state.ctx.gameover !== undefined) {\r\n            return node;\r\n        }\r\n        const id = this.random(actions.length);\r\n        const action = actions[id];\r\n        node.actions.splice(id, 1);\r\n        const childState = this.reducer(node.state, action);\r\n        const childNode = this.createNode({\r\n            state: childState,\r\n            parentAction: action,\r\n            parent: node,\r\n        });\r\n        node.children.push(childNode);\r\n        return childNode;\r\n    }\r\n    playout({ state }) {\r\n        let playoutDepth = this.getOpt('playoutDepth');\r\n        if (typeof this.playoutDepth === 'function') {\r\n            playoutDepth = this.playoutDepth(state.G, state.ctx);\r\n        }\r\n        for (let i = 0; i < playoutDepth && state.ctx.gameover === undefined; i++) {\r\n            const { G, ctx } = state;\r\n            let playerID = ctx.currentPlayer;\r\n            if (ctx.activePlayers) {\r\n                playerID = Object.keys(ctx.activePlayers)[0];\r\n            }\r\n            const moves = this.enumerate(G, ctx, playerID);\r\n            // Check if any objectives are met.\r\n            const objectives = this.objectives(G, ctx, playerID);\r\n            const score = Object.keys(objectives).reduce((score, key) => {\r\n                const objective = objectives[key];\r\n                if (objective.checker(G, ctx)) {\r\n                    return score + objective.weight;\r\n                }\r\n                return score;\r\n            }, 0);\r\n            // If so, stop and return the score.\r\n            if (score > 0) {\r\n                return { score };\r\n            }\r\n            if (!moves || moves.length === 0) {\r\n                return undefined;\r\n            }\r\n            const id = this.random(moves.length);\r\n            const childState = this.reducer(state, moves[id]);\r\n            state = childState;\r\n        }\r\n        return state.ctx.gameover;\r\n    }\r\n    backpropagate(node, result = {}) {\r\n        node.visits++;\r\n        if (result.score !== undefined) {\r\n            node.value += result.score;\r\n        }\r\n        if (result.draw === true) {\r\n            node.value += 0.5;\r\n        }\r\n        if (node.parentAction &&\r\n            result.winner === node.parentAction.payload.playerID) {\r\n            node.value++;\r\n        }\r\n        if (node.parent) {\r\n            this.backpropagate(node.parent, result);\r\n        }\r\n    }\r\n    play(state, playerID) {\r\n        const root = this.createNode({ state, playerID });\r\n        let numIterations = this.getOpt('iterations');\r\n        if (typeof this.iterations === 'function') {\r\n            numIterations = this.iterations(state.G, state.ctx);\r\n        }\r\n        const getResult = () => {\r\n            let selectedChild = null;\r\n            for (const child of root.children) {\r\n                if (selectedChild == null || child.visits > selectedChild.visits) {\r\n                    selectedChild = child;\r\n                }\r\n            }\r\n            const action = selectedChild && selectedChild.parentAction;\r\n            const metadata = root;\r\n            return { action, metadata };\r\n        };\r\n        return new Promise((resolve) => {\r\n            const iteration = () => {\r\n                for (let i = 0; i < CHUNK_SIZE && this.iterationCounter < numIterations; i++) {\r\n                    const leaf = this.select(root);\r\n                    const child = this.expand(leaf);\r\n                    const result = this.playout(child);\r\n                    this.backpropagate(child, result);\r\n                    this.iterationCounter++;\r\n                }\r\n                this.iterationCallback({\r\n                    iterationCounter: this.iterationCounter,\r\n                    numIterations,\r\n                    metadata: root,\r\n                });\r\n            };\r\n            this.iterationCounter = 0;\r\n            if (this.getOpt('async')) {\r\n                const asyncIteration = () => {\r\n                    if (this.iterationCounter < numIterations) {\r\n                        iteration();\r\n                        setImmediate(asyncIteration);\r\n                    }\r\n                    else {\r\n                        resolve(getResult());\r\n                    }\r\n                };\r\n                asyncIteration();\r\n            }\r\n            else {\r\n                while (this.iterationCounter < numIterations) {\r\n                    iteration();\r\n                }\r\n                resolve(getResult());\r\n            }\r\n        });\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Bot that picks a move at random.\r\n */\r\nclass RandomBot extends Bot {\r\n    play({ G, ctx }, playerID) {\r\n        const moves = this.enumerate(G, ctx, playerID);\r\n        return Promise.resolve({ action: this.random(moves) });\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Make a single move on the client with a bot.\r\n *\r\n * @param {...object} client - The game client.\r\n * @param {...object} bot - The bot.\r\n */\r\nasync function Step(client, bot) {\r\n    const state = client.store.getState();\r\n    let playerID = state.ctx.currentPlayer;\r\n    if (state.ctx.activePlayers) {\r\n        playerID = Object.keys(state.ctx.activePlayers)[0];\r\n    }\r\n    const { action, metadata } = await bot.play(state, playerID);\r\n    if (action) {\r\n        const a = {\r\n            ...action,\r\n            payload: {\r\n                ...action.payload,\r\n                metadata,\r\n            },\r\n        };\r\n        client.store.dispatch(a);\r\n        return a;\r\n    }\r\n}\r\n/**\r\n * Simulates the game till the end or a max depth.\r\n *\r\n * @param {...object} game - The game object.\r\n * @param {...object} bots - An array of bots.\r\n * @param {...object} state - The game state to start from.\r\n */\r\nasync function Simulate({ game, bots, state, depth, }) {\r\n    if (depth === undefined)\r\n        depth = 10000;\r\n    const reducer = CreateGameReducer({ game });\r\n    let metadata = null;\r\n    let iter = 0;\r\n    while (state.ctx.gameover === undefined && iter < depth) {\r\n        let playerID = state.ctx.currentPlayer;\r\n        if (state.ctx.activePlayers) {\r\n            playerID = Object.keys(state.ctx.activePlayers)[0];\r\n        }\r\n        const bot = bots instanceof Bot ? bots : bots[playerID];\r\n        const t = await bot.play(state, playerID);\r\n        if (!t.action) {\r\n            break;\r\n        }\r\n        metadata = t.metadata;\r\n        state = reducer(state, t.action);\r\n        iter++;\r\n    }\r\n    return { state, metadata };\r\n}\n\nexport { Bot as B, MCTSBot as M, RandomBot as R, Step as S, Simulate as a };\n"]},"metadata":{},"sourceType":"module"}