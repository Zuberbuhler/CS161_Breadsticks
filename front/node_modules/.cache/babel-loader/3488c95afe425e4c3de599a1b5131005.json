{"ast":null,"code":"import { T as Transport } from './transport-ce07b771.js';\nimport { S as Sync } from './util-b1699aa1.js';\nimport { M as Master } from './master-be1abdd0.js';\nimport { g as getFilterPlayerView } from './filter-player-view-c30cdfbf.js';\nimport ioNamespace__default from 'socket.io-client';\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * InMemory data storage.\r\n */\n\nclass InMemory extends Sync {\n  /**\r\n   * Creates a new InMemory storage.\r\n   */\n  constructor() {\n    super();\n    this.state = new Map();\n    this.initial = new Map();\n    this.metadata = new Map();\n    this.log = new Map();\n  }\n  /**\r\n   * Create a new match.\r\n   *\r\n   * @override\r\n   */\n\n\n  createMatch(matchID, opts) {\n    this.initial.set(matchID, opts.initialState);\n    this.setState(matchID, opts.initialState);\n    this.setMetadata(matchID, opts.metadata);\n  }\n  /**\r\n   * Write the match metadata to the in-memory object.\r\n   */\n\n\n  setMetadata(matchID, metadata) {\n    this.metadata.set(matchID, metadata);\n  }\n  /**\r\n   * Write the match state to the in-memory object.\r\n   */\n\n\n  setState(matchID, state, deltalog) {\n    if (deltalog && deltalog.length > 0) {\n      const log = this.log.get(matchID) || [];\n      this.log.set(matchID, [...log, ...deltalog]);\n    }\n\n    this.state.set(matchID, state);\n  }\n  /**\r\n   * Fetches state for a particular matchID.\r\n   */\n\n\n  fetch(matchID, opts) {\n    const result = {};\n\n    if (opts.state) {\n      result.state = this.state.get(matchID);\n    }\n\n    if (opts.metadata) {\n      result.metadata = this.metadata.get(matchID);\n    }\n\n    if (opts.log) {\n      result.log = this.log.get(matchID) || [];\n    }\n\n    if (opts.initialState) {\n      result.initialState = this.initial.get(matchID);\n    }\n\n    return result;\n  }\n  /**\r\n   * Remove the match state from the in-memory object.\r\n   */\n\n\n  wipe(matchID) {\n    this.state.delete(matchID);\n    this.metadata.delete(matchID);\n  }\n  /**\r\n   * Return all keys.\r\n   *\r\n   * @override\r\n   */\n\n\n  listMatches(opts) {\n    return [...this.metadata.entries()].filter(_ref => {\n      let [, metadata] = _ref;\n\n      if (!opts) {\n        return true;\n      }\n\n      if (opts.gameName !== undefined && metadata.gameName !== opts.gameName) {\n        return false;\n      }\n\n      if (opts.where !== undefined) {\n        if (opts.where.isGameover !== undefined) {\n          const isGameover = metadata.gameover !== undefined;\n\n          if (isGameover !== opts.where.isGameover) {\n            return false;\n          }\n        }\n\n        if (opts.where.updatedBefore !== undefined && metadata.updatedAt >= opts.where.updatedBefore) {\n          return false;\n        }\n\n        if (opts.where.updatedAfter !== undefined && metadata.updatedAt <= opts.where.updatedAfter) {\n          return false;\n        }\n      }\n\n      return true;\n    }).map(_ref2 => {\n      let [key] = _ref2;\n      return key;\n    });\n  }\n\n}\n\nclass WithLocalStorageMap extends Map {\n  constructor(key) {\n    super();\n    this.key = key;\n    const cache = JSON.parse(localStorage.getItem(this.key)) || [];\n    cache.forEach(entry => this.set(...entry));\n  }\n\n  sync() {\n    const entries = [...this.entries()];\n    localStorage.setItem(this.key, JSON.stringify(entries));\n  }\n\n  set(key, value) {\n    super.set(key, value);\n    this.sync();\n    return this;\n  }\n\n  delete(key) {\n    const result = super.delete(key);\n    this.sync();\n    return result;\n  }\n\n}\n/**\r\n * locaStorage data storage.\r\n */\n\n\nclass LocalStorage extends InMemory {\n  constructor() {\n    let storagePrefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'bgio';\n    super();\n\n    const StorageMap = stateKey => new WithLocalStorageMap(`${storagePrefix}_${stateKey}`);\n\n    this.state = StorageMap('state');\n    this.initial = StorageMap('initial');\n    this.metadata = StorageMap('metadata');\n    this.log = StorageMap('log');\n  }\n\n}\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n/**\r\n * Returns null if it is not a bot's turn.\r\n * Otherwise, returns a playerID of a bot that may play now.\r\n */\n\n\nfunction GetBotPlayer(state, bots) {\n  if (state.ctx.gameover !== undefined) {\n    return null;\n  }\n\n  if (state.ctx.activePlayers) {\n    for (const key of Object.keys(bots)) {\n      if (key in state.ctx.activePlayers) {\n        return key;\n      }\n    }\n  } else if (state.ctx.currentPlayer in bots) {\n    return state.ctx.currentPlayer;\n  }\n\n  return null;\n}\n/**\r\n * Creates a local version of the master that the client\r\n * can interact with.\r\n */\n\n\nclass LocalMaster extends Master {\n  constructor(_ref3) {\n    let {\n      game,\n      bots,\n      storageKey,\n      persist\n    } = _ref3;\n    const clientCallbacks = {};\n    const initializedBots = {};\n\n    if (game && game.ai && bots) {\n      for (const playerID in bots) {\n        const bot = bots[playerID];\n        initializedBots[playerID] = new bot({\n          game,\n          enumerate: game.ai.enumerate,\n          seed: game.seed\n        });\n      }\n    }\n\n    const send = _ref4 => {\n      let {\n        playerID,\n        ...data\n      } = _ref4;\n      const callback = clientCallbacks[playerID];\n\n      if (callback !== undefined) {\n        callback(filterPlayerView(playerID, data));\n      }\n    };\n\n    const filterPlayerView = getFilterPlayerView(game);\n    const transportAPI = {\n      send,\n      sendAll: payload => {\n        for (const playerID in clientCallbacks) {\n          send({\n            playerID,\n            ...payload\n          });\n        }\n      }\n    };\n    const storage = persist ? new LocalStorage(storageKey) : new InMemory();\n    super(game, storage, transportAPI);\n\n    this.connect = (playerID, callback) => {\n      clientCallbacks[playerID] = callback;\n    };\n\n    this.subscribe(_ref5 => {\n      let {\n        state,\n        matchID\n      } = _ref5;\n\n      if (!bots) {\n        return;\n      }\n\n      const botPlayer = GetBotPlayer(state, initializedBots);\n\n      if (botPlayer !== null) {\n        setTimeout(async () => {\n          const botAction = await initializedBots[botPlayer].play(state, botPlayer);\n          await this.onUpdate(botAction.action, state._stateID, matchID, botAction.action.payload.playerID);\n        }, 100);\n      }\n    });\n  }\n\n}\n/**\r\n * Local\r\n *\r\n * Transport interface that embeds a GameMaster within it\r\n * that you can connect multiple clients to.\r\n */\n\n\nclass LocalTransport extends Transport {\n  /**\r\n   * Creates a new Mutiplayer instance.\r\n   * @param {string} matchID - The game ID to connect to.\r\n   * @param {string} playerID - The player ID associated with this client.\r\n   * @param {string} gameName - The game type (the `name` field in `Game`).\r\n   * @param {string} numPlayers - The number of players.\r\n   */\n  constructor(_ref6) {\n    let {\n      master,\n      ...opts\n    } = _ref6;\n    super(opts);\n    this.master = master;\n  }\n\n  sendChatMessage(matchID, chatMessage) {\n    const args = [matchID, chatMessage, this.credentials];\n    this.master.onChatMessage(...args);\n  }\n\n  sendAction(state, action) {\n    this.master.onUpdate(action, state._stateID, this.matchID, this.playerID);\n  }\n\n  requestSync() {\n    this.master.onSync(this.matchID, this.playerID, this.credentials, this.numPlayers);\n  }\n\n  connect() {\n    this.setConnectionStatus(true);\n    this.master.connect(this.playerID, data => this.notifyClient(data));\n    this.requestSync();\n  }\n\n  disconnect() {\n    this.setConnectionStatus(false);\n  }\n\n  updateMatchID(id) {\n    this.matchID = id;\n    this.connect();\n  }\n\n  updatePlayerID(id) {\n    this.playerID = id;\n    this.connect();\n  }\n\n  updateCredentials(credentials) {\n    this.credentials = credentials;\n    this.connect();\n  }\n\n}\n/**\r\n * Global map storing local master instances.\r\n */\n\n\nconst localMasters = new Map();\n/**\r\n * Create a local transport.\r\n */\n\nfunction Local() {\n  let {\n    bots,\n    persist,\n    storageKey\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return transportOpts => {\n    const {\n      gameKey,\n      game\n    } = transportOpts;\n    let master;\n    const instance = localMasters.get(gameKey);\n\n    if (instance && instance.bots === bots && instance.storageKey === storageKey && instance.persist === persist) {\n      master = instance.master;\n    }\n\n    if (!master) {\n      master = new LocalMaster({\n        game,\n        bots,\n        persist,\n        storageKey\n      });\n      localMasters.set(gameKey, {\n        master,\n        bots,\n        persist,\n        storageKey\n      });\n    }\n\n    return new LocalTransport({\n      master,\n      ...transportOpts\n    });\n  };\n}\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\n\n\nconst io = ioNamespace__default;\n/**\r\n * SocketIO\r\n *\r\n * Transport interface that interacts with the Master via socket.io.\r\n */\n\nclass SocketIOTransport extends Transport {\n  /**\r\n   * Creates a new Multiplayer instance.\r\n   * @param {object} socket - Override for unit tests.\r\n   * @param {object} socketOpts - Options to pass to socket.io.\r\n   * @param {object} store - Redux store\r\n   * @param {string} matchID - The game ID to connect to.\r\n   * @param {string} playerID - The player ID associated with this client.\r\n   * @param {string} credentials - Authentication credentials\r\n   * @param {string} gameName - The game type (the `name` field in `Game`).\r\n   * @param {string} numPlayers - The number of players.\r\n   * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\r\n   */\n  constructor(_ref7) {\n    let {\n      socket,\n      socketOpts,\n      server,\n      ...opts\n    } = _ref7;\n    super(opts);\n    this.server = server;\n    this.socket = socket;\n    this.socketOpts = socketOpts;\n  }\n\n  sendAction(state, action) {\n    const args = [action, state._stateID, this.matchID, this.playerID];\n    this.socket.emit('update', ...args);\n  }\n\n  sendChatMessage(matchID, chatMessage) {\n    const args = [matchID, chatMessage, this.credentials];\n    this.socket.emit('chat', ...args);\n  }\n\n  connect() {\n    if (!this.socket) {\n      if (this.server) {\n        let server = this.server;\n\n        if (server.search(/^https?:\\/\\//) == -1) {\n          server = 'http://' + this.server;\n        }\n\n        if (server.slice(-1) != '/') {\n          // add trailing slash if not already present\n          server = server + '/';\n        }\n\n        this.socket = io(server + this.gameName, this.socketOpts);\n      } else {\n        this.socket = io('/' + this.gameName, this.socketOpts);\n      }\n    } // Called when another player makes a move and the\n    // master broadcasts the update as a patch to other clients (including\n    // this one).\n\n\n    this.socket.on('patch', (matchID, prevStateID, stateID, patch, deltalog) => {\n      this.notifyClient({\n        type: 'patch',\n        args: [matchID, prevStateID, stateID, patch, deltalog]\n      });\n    }); // Called when another player makes a move and the\n    // master broadcasts the update to other clients (including\n    // this one).\n\n    this.socket.on('update', (matchID, state, deltalog) => {\n      this.notifyClient({\n        type: 'update',\n        args: [matchID, state, deltalog]\n      });\n    }); // Called when the client first connects to the master\n    // and requests the current game state.\n\n    this.socket.on('sync', (matchID, syncInfo) => {\n      this.notifyClient({\n        type: 'sync',\n        args: [matchID, syncInfo]\n      });\n    }); // Called when new player joins the match or changes\n    // it's connection status\n\n    this.socket.on('matchData', (matchID, matchData) => {\n      this.notifyClient({\n        type: 'matchData',\n        args: [matchID, matchData]\n      });\n    });\n    this.socket.on('chat', (matchID, chatMessage) => {\n      this.notifyClient({\n        type: 'chat',\n        args: [matchID, chatMessage]\n      });\n    }); // Keep track of connection status.\n\n    this.socket.on('connect', () => {\n      // Initial sync to get game state.\n      this.requestSync();\n      this.setConnectionStatus(true);\n    });\n    this.socket.on('disconnect', () => {\n      this.setConnectionStatus(false);\n    });\n  }\n\n  disconnect() {\n    this.socket.close();\n    this.socket = null;\n    this.setConnectionStatus(false);\n  }\n\n  requestSync() {\n    if (this.socket) {\n      const args = [this.matchID, this.playerID, this.credentials, this.numPlayers];\n      this.socket.emit('sync', ...args);\n    }\n  }\n\n  updateMatchID(id) {\n    this.matchID = id;\n    this.requestSync();\n  }\n\n  updatePlayerID(id) {\n    this.playerID = id;\n    this.requestSync();\n  }\n\n  updateCredentials(credentials) {\n    this.credentials = credentials;\n    this.requestSync();\n  }\n\n}\n\nfunction SocketIO() {\n  let {\n    server,\n    socketOpts\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return transportOpts => new SocketIOTransport({\n    server,\n    socketOpts,\n    ...transportOpts\n  });\n}\n\nexport { Local as L, SocketIO as S };","map":{"version":3,"sources":["/Users/andywang/Desktop/CS161_Breadsticks/node_modules/boardgame.io/dist/esm/socketio-e4fb268a.js"],"names":["T","Transport","S","Sync","M","Master","g","getFilterPlayerView","ioNamespace__default","InMemory","constructor","state","Map","initial","metadata","log","createMatch","matchID","opts","set","initialState","setState","setMetadata","deltalog","length","get","fetch","result","wipe","delete","listMatches","entries","filter","gameName","undefined","where","isGameover","gameover","updatedBefore","updatedAt","updatedAfter","map","key","WithLocalStorageMap","cache","JSON","parse","localStorage","getItem","forEach","entry","sync","setItem","stringify","value","LocalStorage","storagePrefix","StorageMap","stateKey","GetBotPlayer","bots","ctx","activePlayers","Object","keys","currentPlayer","LocalMaster","game","storageKey","persist","clientCallbacks","initializedBots","ai","playerID","bot","enumerate","seed","send","data","callback","filterPlayerView","transportAPI","sendAll","payload","storage","connect","subscribe","botPlayer","setTimeout","botAction","play","onUpdate","action","_stateID","LocalTransport","master","sendChatMessage","chatMessage","args","credentials","onChatMessage","sendAction","requestSync","onSync","numPlayers","setConnectionStatus","notifyClient","disconnect","updateMatchID","id","updatePlayerID","updateCredentials","localMasters","Local","transportOpts","gameKey","instance","io","SocketIOTransport","socket","socketOpts","server","emit","search","slice","on","prevStateID","stateID","patch","type","syncInfo","matchData","close","SocketIO","L"],"mappings":"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","sourcesContent":["import { T as Transport } from './transport-ce07b771.js';\nimport { S as Sync } from './util-b1699aa1.js';\nimport { M as Master } from './master-be1abdd0.js';\nimport { g as getFilterPlayerView } from './filter-player-view-c30cdfbf.js';\nimport ioNamespace__default from 'socket.io-client';\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * InMemory data storage.\r\n */\r\nclass InMemory extends Sync {\r\n    /**\r\n     * Creates a new InMemory storage.\r\n     */\r\n    constructor() {\r\n        super();\r\n        this.state = new Map();\r\n        this.initial = new Map();\r\n        this.metadata = new Map();\r\n        this.log = new Map();\r\n    }\r\n    /**\r\n     * Create a new match.\r\n     *\r\n     * @override\r\n     */\r\n    createMatch(matchID, opts) {\r\n        this.initial.set(matchID, opts.initialState);\r\n        this.setState(matchID, opts.initialState);\r\n        this.setMetadata(matchID, opts.metadata);\r\n    }\r\n    /**\r\n     * Write the match metadata to the in-memory object.\r\n     */\r\n    setMetadata(matchID, metadata) {\r\n        this.metadata.set(matchID, metadata);\r\n    }\r\n    /**\r\n     * Write the match state to the in-memory object.\r\n     */\r\n    setState(matchID, state, deltalog) {\r\n        if (deltalog && deltalog.length > 0) {\r\n            const log = this.log.get(matchID) || [];\r\n            this.log.set(matchID, [...log, ...deltalog]);\r\n        }\r\n        this.state.set(matchID, state);\r\n    }\r\n    /**\r\n     * Fetches state for a particular matchID.\r\n     */\r\n    fetch(matchID, opts) {\r\n        const result = {};\r\n        if (opts.state) {\r\n            result.state = this.state.get(matchID);\r\n        }\r\n        if (opts.metadata) {\r\n            result.metadata = this.metadata.get(matchID);\r\n        }\r\n        if (opts.log) {\r\n            result.log = this.log.get(matchID) || [];\r\n        }\r\n        if (opts.initialState) {\r\n            result.initialState = this.initial.get(matchID);\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Remove the match state from the in-memory object.\r\n     */\r\n    wipe(matchID) {\r\n        this.state.delete(matchID);\r\n        this.metadata.delete(matchID);\r\n    }\r\n    /**\r\n     * Return all keys.\r\n     *\r\n     * @override\r\n     */\r\n    listMatches(opts) {\r\n        return [...this.metadata.entries()]\r\n            .filter(([, metadata]) => {\r\n            if (!opts) {\r\n                return true;\r\n            }\r\n            if (opts.gameName !== undefined &&\r\n                metadata.gameName !== opts.gameName) {\r\n                return false;\r\n            }\r\n            if (opts.where !== undefined) {\r\n                if (opts.where.isGameover !== undefined) {\r\n                    const isGameover = metadata.gameover !== undefined;\r\n                    if (isGameover !== opts.where.isGameover) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (opts.where.updatedBefore !== undefined &&\r\n                    metadata.updatedAt >= opts.where.updatedBefore) {\r\n                    return false;\r\n                }\r\n                if (opts.where.updatedAfter !== undefined &&\r\n                    metadata.updatedAt <= opts.where.updatedAfter) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        })\r\n            .map(([key]) => key);\r\n    }\r\n}\n\nclass WithLocalStorageMap extends Map {\r\n    constructor(key) {\r\n        super();\r\n        this.key = key;\r\n        const cache = JSON.parse(localStorage.getItem(this.key)) || [];\r\n        cache.forEach((entry) => this.set(...entry));\r\n    }\r\n    sync() {\r\n        const entries = [...this.entries()];\r\n        localStorage.setItem(this.key, JSON.stringify(entries));\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value);\r\n        this.sync();\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        const result = super.delete(key);\r\n        this.sync();\r\n        return result;\r\n    }\r\n}\r\n/**\r\n * locaStorage data storage.\r\n */\r\nclass LocalStorage extends InMemory {\r\n    constructor(storagePrefix = 'bgio') {\r\n        super();\r\n        const StorageMap = (stateKey) => new WithLocalStorageMap(`${storagePrefix}_${stateKey}`);\r\n        this.state = StorageMap('state');\r\n        this.initial = StorageMap('initial');\r\n        this.metadata = StorageMap('metadata');\r\n        this.log = StorageMap('log');\r\n    }\r\n}\n\n/*\r\n * Copyright 2018 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\n/**\r\n * Returns null if it is not a bot's turn.\r\n * Otherwise, returns a playerID of a bot that may play now.\r\n */\r\nfunction GetBotPlayer(state, bots) {\r\n    if (state.ctx.gameover !== undefined) {\r\n        return null;\r\n    }\r\n    if (state.ctx.activePlayers) {\r\n        for (const key of Object.keys(bots)) {\r\n            if (key in state.ctx.activePlayers) {\r\n                return key;\r\n            }\r\n        }\r\n    }\r\n    else if (state.ctx.currentPlayer in bots) {\r\n        return state.ctx.currentPlayer;\r\n    }\r\n    return null;\r\n}\r\n/**\r\n * Creates a local version of the master that the client\r\n * can interact with.\r\n */\r\nclass LocalMaster extends Master {\r\n    constructor({ game, bots, storageKey, persist }) {\r\n        const clientCallbacks = {};\r\n        const initializedBots = {};\r\n        if (game && game.ai && bots) {\r\n            for (const playerID in bots) {\r\n                const bot = bots[playerID];\r\n                initializedBots[playerID] = new bot({\r\n                    game,\r\n                    enumerate: game.ai.enumerate,\r\n                    seed: game.seed,\r\n                });\r\n            }\r\n        }\r\n        const send = ({ playerID, ...data }) => {\r\n            const callback = clientCallbacks[playerID];\r\n            if (callback !== undefined) {\r\n                callback(filterPlayerView(playerID, data));\r\n            }\r\n        };\r\n        const filterPlayerView = getFilterPlayerView(game);\r\n        const transportAPI = {\r\n            send,\r\n            sendAll: (payload) => {\r\n                for (const playerID in clientCallbacks) {\r\n                    send({ playerID, ...payload });\r\n                }\r\n            },\r\n        };\r\n        const storage = persist ? new LocalStorage(storageKey) : new InMemory();\r\n        super(game, storage, transportAPI);\r\n        this.connect = (playerID, callback) => {\r\n            clientCallbacks[playerID] = callback;\r\n        };\r\n        this.subscribe(({ state, matchID }) => {\r\n            if (!bots) {\r\n                return;\r\n            }\r\n            const botPlayer = GetBotPlayer(state, initializedBots);\r\n            if (botPlayer !== null) {\r\n                setTimeout(async () => {\r\n                    const botAction = await initializedBots[botPlayer].play(state, botPlayer);\r\n                    await this.onUpdate(botAction.action, state._stateID, matchID, botAction.action.payload.playerID);\r\n                }, 100);\r\n            }\r\n        });\r\n    }\r\n}\r\n/**\r\n * Local\r\n *\r\n * Transport interface that embeds a GameMaster within it\r\n * that you can connect multiple clients to.\r\n */\r\nclass LocalTransport extends Transport {\r\n    /**\r\n     * Creates a new Mutiplayer instance.\r\n     * @param {string} matchID - The game ID to connect to.\r\n     * @param {string} playerID - The player ID associated with this client.\r\n     * @param {string} gameName - The game type (the `name` field in `Game`).\r\n     * @param {string} numPlayers - The number of players.\r\n     */\r\n    constructor({ master, ...opts }) {\r\n        super(opts);\r\n        this.master = master;\r\n    }\r\n    sendChatMessage(matchID, chatMessage) {\r\n        const args = [\r\n            matchID,\r\n            chatMessage,\r\n            this.credentials,\r\n        ];\r\n        this.master.onChatMessage(...args);\r\n    }\r\n    sendAction(state, action) {\r\n        this.master.onUpdate(action, state._stateID, this.matchID, this.playerID);\r\n    }\r\n    requestSync() {\r\n        this.master.onSync(this.matchID, this.playerID, this.credentials, this.numPlayers);\r\n    }\r\n    connect() {\r\n        this.setConnectionStatus(true);\r\n        this.master.connect(this.playerID, (data) => this.notifyClient(data));\r\n        this.requestSync();\r\n    }\r\n    disconnect() {\r\n        this.setConnectionStatus(false);\r\n    }\r\n    updateMatchID(id) {\r\n        this.matchID = id;\r\n        this.connect();\r\n    }\r\n    updatePlayerID(id) {\r\n        this.playerID = id;\r\n        this.connect();\r\n    }\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.connect();\r\n    }\r\n}\r\n/**\r\n * Global map storing local master instances.\r\n */\r\nconst localMasters = new Map();\r\n/**\r\n * Create a local transport.\r\n */\r\nfunction Local({ bots, persist, storageKey } = {}) {\r\n    return (transportOpts) => {\r\n        const { gameKey, game } = transportOpts;\r\n        let master;\r\n        const instance = localMasters.get(gameKey);\r\n        if (instance &&\r\n            instance.bots === bots &&\r\n            instance.storageKey === storageKey &&\r\n            instance.persist === persist) {\r\n            master = instance.master;\r\n        }\r\n        if (!master) {\r\n            master = new LocalMaster({ game, bots, persist, storageKey });\r\n            localMasters.set(gameKey, { master, bots, persist, storageKey });\r\n        }\r\n        return new LocalTransport({ master, ...transportOpts });\r\n    };\r\n}\n\n/*\r\n * Copyright 2017 The boardgame.io Authors\r\n *\r\n * Use of this source code is governed by a MIT-style\r\n * license that can be found in the LICENSE file or at\r\n * https://opensource.org/licenses/MIT.\r\n */\r\nconst io = ioNamespace__default;\r\n/**\r\n * SocketIO\r\n *\r\n * Transport interface that interacts with the Master via socket.io.\r\n */\r\nclass SocketIOTransport extends Transport {\r\n    /**\r\n     * Creates a new Multiplayer instance.\r\n     * @param {object} socket - Override for unit tests.\r\n     * @param {object} socketOpts - Options to pass to socket.io.\r\n     * @param {object} store - Redux store\r\n     * @param {string} matchID - The game ID to connect to.\r\n     * @param {string} playerID - The player ID associated with this client.\r\n     * @param {string} credentials - Authentication credentials\r\n     * @param {string} gameName - The game type (the `name` field in `Game`).\r\n     * @param {string} numPlayers - The number of players.\r\n     * @param {string} server - The game server in the form of 'hostname:port'. Defaults to the server serving the client if not provided.\r\n     */\r\n    constructor({ socket, socketOpts, server, ...opts }) {\r\n        super(opts);\r\n        this.server = server;\r\n        this.socket = socket;\r\n        this.socketOpts = socketOpts;\r\n    }\r\n    sendAction(state, action) {\r\n        const args = [\r\n            action,\r\n            state._stateID,\r\n            this.matchID,\r\n            this.playerID,\r\n        ];\r\n        this.socket.emit('update', ...args);\r\n    }\r\n    sendChatMessage(matchID, chatMessage) {\r\n        const args = [\r\n            matchID,\r\n            chatMessage,\r\n            this.credentials,\r\n        ];\r\n        this.socket.emit('chat', ...args);\r\n    }\r\n    connect() {\r\n        if (!this.socket) {\r\n            if (this.server) {\r\n                let server = this.server;\r\n                if (server.search(/^https?:\\/\\//) == -1) {\r\n                    server = 'http://' + this.server;\r\n                }\r\n                if (server.slice(-1) != '/') {\r\n                    // add trailing slash if not already present\r\n                    server = server + '/';\r\n                }\r\n                this.socket = io(server + this.gameName, this.socketOpts);\r\n            }\r\n            else {\r\n                this.socket = io('/' + this.gameName, this.socketOpts);\r\n            }\r\n        }\r\n        // Called when another player makes a move and the\r\n        // master broadcasts the update as a patch to other clients (including\r\n        // this one).\r\n        this.socket.on('patch', (matchID, prevStateID, stateID, patch, deltalog) => {\r\n            this.notifyClient({\r\n                type: 'patch',\r\n                args: [matchID, prevStateID, stateID, patch, deltalog],\r\n            });\r\n        });\r\n        // Called when another player makes a move and the\r\n        // master broadcasts the update to other clients (including\r\n        // this one).\r\n        this.socket.on('update', (matchID, state, deltalog) => {\r\n            this.notifyClient({\r\n                type: 'update',\r\n                args: [matchID, state, deltalog],\r\n            });\r\n        });\r\n        // Called when the client first connects to the master\r\n        // and requests the current game state.\r\n        this.socket.on('sync', (matchID, syncInfo) => {\r\n            this.notifyClient({ type: 'sync', args: [matchID, syncInfo] });\r\n        });\r\n        // Called when new player joins the match or changes\r\n        // it's connection status\r\n        this.socket.on('matchData', (matchID, matchData) => {\r\n            this.notifyClient({ type: 'matchData', args: [matchID, matchData] });\r\n        });\r\n        this.socket.on('chat', (matchID, chatMessage) => {\r\n            this.notifyClient({ type: 'chat', args: [matchID, chatMessage] });\r\n        });\r\n        // Keep track of connection status.\r\n        this.socket.on('connect', () => {\r\n            // Initial sync to get game state.\r\n            this.requestSync();\r\n            this.setConnectionStatus(true);\r\n        });\r\n        this.socket.on('disconnect', () => {\r\n            this.setConnectionStatus(false);\r\n        });\r\n    }\r\n    disconnect() {\r\n        this.socket.close();\r\n        this.socket = null;\r\n        this.setConnectionStatus(false);\r\n    }\r\n    requestSync() {\r\n        if (this.socket) {\r\n            const args = [\r\n                this.matchID,\r\n                this.playerID,\r\n                this.credentials,\r\n                this.numPlayers,\r\n            ];\r\n            this.socket.emit('sync', ...args);\r\n        }\r\n    }\r\n    updateMatchID(id) {\r\n        this.matchID = id;\r\n        this.requestSync();\r\n    }\r\n    updatePlayerID(id) {\r\n        this.playerID = id;\r\n        this.requestSync();\r\n    }\r\n    updateCredentials(credentials) {\r\n        this.credentials = credentials;\r\n        this.requestSync();\r\n    }\r\n}\r\nfunction SocketIO({ server, socketOpts } = {}) {\r\n    return (transportOpts) => new SocketIOTransport({\r\n        server,\r\n        socketOpts,\r\n        ...transportOpts,\r\n    });\r\n}\n\nexport { Local as L, SocketIO as S };\n"]},"metadata":{},"sourceType":"module"}