{"ast":null,"code":"import { INVALID_MOVE } from 'boardgame.io/core'; // Return true if `cells` is in a winning configuration.\n\nfunction IsVictory(cells) {\n  const positions = [[0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]];\n\n  const isRowComplete = row => {\n    const symbols = row.map(i => cells[i]);\n    return symbols.every(i => i !== null && i === symbols[0]);\n  };\n\n  return positions.map(isRowComplete).some(i => i === true);\n} // Return true if all `cells` are occupied.\n\n\n_c = IsVictory;\n\nfunction IsDraw(cells) {\n  return cells.filter(c => c === null).length === 0;\n}\n\n_c2 = IsDraw;\nexport const TicTacToe = {\n  setup: () => ({\n    cells: Array(9).fill(null)\n  }),\n  // min and max number of turns\n  turn: {\n    minMoves: 1,\n    maxMoves: 1\n  },\n  moves: {\n    clickCell: (G, ctx, id) => {\n      if (G.cells[id] !== null) {\n        return INVALID_MOVE;\n      }\n\n      G.cells[id] = ctx.currentPlayer;\n    }\n  },\n  endIf: (G, ctx) => {\n    if (IsVictory(G.cells)) {\n      return {\n        winner: ctx.currentPlayer\n      };\n    }\n\n    if (IsDraw(G.cells)) {\n      return {\n        draw: true\n      };\n    }\n  }\n};\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"IsVictory\");\n$RefreshReg$(_c2, \"IsDraw\");","map":{"version":3,"sources":["/Users/andywang/Desktop/CS161_Breadsticks/front/src/components/Game.js"],"names":["INVALID_MOVE","IsVictory","cells","positions","isRowComplete","row","symbols","map","i","every","some","IsDraw","filter","c","length","TicTacToe","setup","Array","fill","turn","minMoves","maxMoves","moves","clickCell","G","ctx","id","currentPlayer","endIf","winner","draw"],"mappings":"AAAA,SAASA,YAAT,QAA6B,mBAA7B,C,CAEA;;AACA,SAASC,SAAT,CAAmBC,KAAnB,EAA0B;AACtB,QAAMC,SAAS,GAAG,CAChB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADgB,EACL,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADK,EACM,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADN,EACiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CADjB,EAEhB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFgB,EAEL,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFK,EAEM,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFN,EAEiB,CAAC,CAAD,EAAI,CAAJ,EAAO,CAAP,CAFjB,CAAlB;;AAKA,QAAMC,aAAa,GAAGC,GAAG,IAAI;AAC3B,UAAMC,OAAO,GAAGD,GAAG,CAACE,GAAJ,CAAQC,CAAC,IAAIN,KAAK,CAACM,CAAD,CAAlB,CAAhB;AACA,WAAOF,OAAO,CAACG,KAAR,CAAcD,CAAC,IAAIA,CAAC,KAAK,IAAN,IAAcA,CAAC,KAAKF,OAAO,CAAC,CAAD,CAA9C,CAAP;AACD,GAHD;;AAKA,SAAOH,SAAS,CAACI,GAAV,CAAcH,aAAd,EAA6BM,IAA7B,CAAkCF,CAAC,IAAIA,CAAC,KAAK,IAA7C,CAAP;AACH,C,CAED;;;KAdSP,S;;AAeT,SAASU,MAAT,CAAgBT,KAAhB,EAAuB;AACnB,SAAOA,KAAK,CAACU,MAAN,CAAaC,CAAC,IAAIA,CAAC,KAAK,IAAxB,EAA8BC,MAA9B,KAAyC,CAAhD;AACH;;MAFQH,M;AAIT,OAAO,MAAMI,SAAS,GAAG;AACrBC,EAAAA,KAAK,EAAE,OAAO;AAAEd,IAAAA,KAAK,EAAEe,KAAK,CAAC,CAAD,CAAL,CAASC,IAAT,CAAc,IAAd;AAAT,GAAP,CADc;AAGrB;AACAC,EAAAA,IAAI,EAAE;AACFC,IAAAA,QAAQ,EAAE,CADR;AAEFC,IAAAA,QAAQ,EAAE;AAFR,GAJe;AASrBC,EAAAA,KAAK,EAAE;AACLC,IAAAA,SAAS,EAAE,CAACC,CAAD,EAAIC,GAAJ,EAASC,EAAT,KAAgB;AACzB,UAAIF,CAAC,CAACtB,KAAF,CAAQwB,EAAR,MAAgB,IAApB,EAA0B;AACtB,eAAO1B,YAAP;AACD;;AACDwB,MAAAA,CAAC,CAACtB,KAAF,CAAQwB,EAAR,IAAcD,GAAG,CAACE,aAAlB;AACH;AANI,GATc;AAkBrBC,EAAAA,KAAK,EAAE,CAACJ,CAAD,EAAIC,GAAJ,KAAY;AACf,QAAIxB,SAAS,CAACuB,CAAC,CAACtB,KAAH,CAAb,EAAwB;AACtB,aAAO;AAAE2B,QAAAA,MAAM,EAAEJ,GAAG,CAACE;AAAd,OAAP;AACD;;AACD,QAAIhB,MAAM,CAACa,CAAC,CAACtB,KAAH,CAAV,EAAqB;AACnB,aAAO;AAAE4B,QAAAA,IAAI,EAAE;AAAR,OAAP;AACD;AACJ;AAzBoB,CAAlB","sourcesContent":["import { INVALID_MOVE } from 'boardgame.io/core';\n\n// Return true if `cells` is in a winning configuration.\nfunction IsVictory(cells) {\n    const positions = [\n      [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6],\n      [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]\n    ];\n  \n    const isRowComplete = row => {\n      const symbols = row.map(i => cells[i]);\n      return symbols.every(i => i !== null && i === symbols[0]);\n    };\n  \n    return positions.map(isRowComplete).some(i => i === true);\n}\n  \n// Return true if all `cells` are occupied.\nfunction IsDraw(cells) {\n    return cells.filter(c => c === null).length === 0;\n}\n\nexport const TicTacToe = {\n    setup: () => ({ cells: Array(9).fill(null) }),\n  \n    // min and max number of turns\n    turn: {\n        minMoves: 1,\n        maxMoves: 1,\n    },\n\n    moves: {\n      clickCell: (G, ctx, id) => {\n        if (G.cells[id] !== null) {\n            return INVALID_MOVE;\n          }\n          G.cells[id] = ctx.currentPlayer;\n      },\n    },\n\n    endIf: (G, ctx) => {\n        if (IsVictory(G.cells)) {\n          return { winner: ctx.currentPlayer };\n        }\n        if (IsDraw(G.cells)) {\n          return { draw: true };\n        }\n    },\n  };"]},"metadata":{},"sourceType":"module"}